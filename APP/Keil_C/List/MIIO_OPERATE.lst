C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MIIO_OPERATE
OBJECT MODULE PLACED IN ..\Output\MIIO_OPERATE.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\IOT_DRIVER\XIAOMI\MIIO_OPERATE.C LARGE OMF2 OPTIMIZE(8,SIZE) BROWSE I
                    -NTVECTOR(0X2800) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..\
                    -Apps;..\Apps) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\MIIO_OPERATE.lst) TABS(2) OBJECT(..\Output\MIIO_OPERATE.obj)

line level    source

   1          #include "IOTCONFIG_XIAOMI.H"
   2          
   3          unsigned char  IOT_Uart_DataBuf[256];
   4          
   5          unsigned char XMClient_Buffer[XMODERN_BUFFER_SIZE];
   6          volatile System_t System;
   7          XmodemStatus_t XS_Result;
   8          MIIO_Result_t miio_result = MIR_NA; 
   9          
  10          
  11          volatile MIIO_IAP_t MIIO_IAP;
  12          
  13          
  14          XmodemClient_t XMClient;
  15          
  16          u32 File_crc;
  17          u8  FileCrcerror=0;
  18          u8 SaveXmodemData[256];
  19          
  20          //====================================================================================================
  21          //====================================================================================================
  22          bool CmpStr(char *Uart_Rdata,unsigned char* string)
  23          {
  24   1        unsigned int i=0;
  25   1          while(*string)
  26   1          {
  27   2          if(Uart_Rdata[i++]!=*string++)
  28   2          {
  29   3            return false;
  30   3          }
  31   2          }
  32   1        return true;
  33   1      }
  34          //====================================================================================================
  35          //====================================================================================================
  36          void MIIO_IAP_InData(s8 Data)
  37          {
  38   1        MIIO_IAP.Buffer.Memory[MIIO_IAP.Buffer.Count]=Data;
  39   1        MIIO_IAP.Buffer.Count++;
  40   1        if(MIIO_IAP.Buffer.Count>sizeof(MIIO_IAP.Buffer.Memory))
  41   1        {
  42   2          MIIO_IAP.Buffer.Count=0;
  43   2        }
  44   1        if(Data=='\r')
  45   1        { 
  46   2          MIIO_IAP.State=MI_Rx;
  47   2        }
  48   1      }
  49          //====================================================================================================
  50          //====================================================================================================
  51          MIIO_Result_t MIIO_IAP_Cmd(char *cmd,                     //
  52                                     char *reply1,              //
  53                                     char *reply2,              //
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 2   

  54                                     u32 TimeOut,               //
  55                                     void UR_Send(char *Udata)) //
  56          {
  57   1        
  58   1        if((MIIO_IAP.State!=MI_Tx)&&(MIIO_IAP.State!=MI_Rx))
  59   1        {
  60   2          UR_Send(cmd);
  61   2          MIIO_IAP.State=MI_Tx;
  62   2          MIIO_IAP.Time.Count=0;
  63   2        }
  64   1        if(MIIO_IAP.State==MI_Rx)
  65   1        {
  66   2          MIIO_IAP.Buffer.Count=0;
  67   2          MIIO_IAP.State=MI_Wait;
  68   2          if(CmpStr(MIIO_IAP.Buffer.Memory,reply1))
  69   2          {
  70   3            return MIR_R1;
  71   3          }
  72   2          if(CmpStr(MIIO_IAP.Buffer.Memory,reply2))
  73   2          {
  74   3            return MIR_R2;
  75   3          }   
  76   2          return MIR_NA;
  77   2        }
  78   1        if(MIIO_IAP.Time.Count>TimeOut)
  79   1        {
  80   2          MIIO_IAP.Time.Count=0;
  81   2          MIIO_IAP.State=MIR_TO;
  82   2        }
  83   1        
  84   1        return MIR_NA;
  85   1      }
  86          
  87          
  88          void XmodemClient_ModeInit(XmodemModeVER_t modever, //
  89                                     u8 *PackMemory)          // Size 133Byte
  90          {
  91   1        XMClient.ModeVER=modever;
  92   1        XMClient.Time.Limit=1000;  //1s
  93   1        XMClient.Package.Memory=PackMemory;
  94   1        XMClient.Package.Count=0;
  95   1        XMClient.Package.Size=0;
  96   1        XMClient.Phase=XP_Start;
  97   1      }
  98          
  99          XmodemStatus_t XmodemClient_Proess(IAPDATA_INFO *OTA_Data)
 100          {
 101   1        static u16  IAP_Count;
 102   1        static u8  ErrorCount;
 103   1        u16 crc=0;
 104   1        
 105   1        u8  IapLen;
 106   1        
 107   1        if(XMClient.Phase==XP_Start)
 108   1        {
 109   2          UART_SendByte(XR_C);
 110   2          XMClient.Phase=XP_Packing;
 111   2          XMClient.State=XS_Receive;
 112   2          XMClient.Time.Count=0;
 113   2          ErrorCount=0;
 114   2          IAP_Size=0;
 115   2          IAP_Count=1;
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 3   

 116   2          FileCrcerror=0;
 117   2          File_crc=0;
 118   2        }
 119   1        if((XMClient.Time.Count>XMClient.Time.Limit))//&&(XMClient.Phase==XS_Receive))  //接收超时
 120   1        {
 121   2          ErrorCount+=1;
 122   2          UART_SendByte(XR_NACK);
 123   2          XMClient.Time.Count=0;
 124   2        }
 125   1          
 126   1        if((XMClient.Phase==XS_Receive)&&(XMClient.Package.Size>=1))
 127   1        {
 128   2          if(XMClient.Package.Memory[0]==XR_EOT) //完成发送
 129   2          {
 130   3            u8  i,j;
 131   3            
 132   3            for(i=0;i<255;i++)
 133   3            {
 134   4              if((0xFF==SaveXmodemData[255-i])&&(0x1A==SaveXmodemData[255-i-1]))
 135   4              {
 136   5                break;
 137   5              }
 138   4                
 139   4            }
 140   3            i=i+2+4;
 141   3            File_crc=CRC32_Xmodem(File_crc,&SaveXmodemData[0],256-i);
 142   3      
 143   3            for(j=0;j<4;j++)
 144   3            {
 145   4              if((uint8_t)File_crc!=SaveXmodemData[256-i+j])
 146   4              {
 147   5                FileCrcerror=1;
 148   5                break;
 149   5              }
 150   4              File_crc=File_crc>>8;
 151   4            }       
 152   3            
 153   3            XMClient.Time.Count=0;
 154   3            XMClient.Package.Size=0;
 155   3      
 156   3            XMClient.State=XS_ReceiveEnd;
 157   3            XMClient.Phase=XP_PackEnd;
 158   3            UART_SendByte(XR_ACK);
 159   3            return XS_Finish;
 160   3          }
 161   2          if(XMClient.Package.Memory[0]==XR_CAN) //取消发送
 162   2          {
 163   3          
 164   3            
 165   3            
 166   3            XMClient.Time.Count=0;
 167   3            XMClient.Package.Size=0;
 168   3      
 169   3            XMClient.State=XS_Error;
 170   3            XMClient.Phase=XP_PackEnd;
 171   3            UART_SendByte(XR_ACK);
 172   3            return XS_Fault;
 173   3          }   
 174   2          if(XMClient.Package.Size>XMODERN_BUFFER_SIZE) //接收一帧错误
 175   2          {
 176   3            XMClient.Time.Count=0;
 177   3            ErrorCount+=1;
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 4   

 178   3            XMClient.Package.Size=0;
 179   3            UART_SendByte(XR_NACK);
 180   3          }       
 181   2          if((XMClient.Package.Memory[0]==XR_SOH)&&(XMClient.Package.Size==XMODERN_BUFFER_SIZE))
 182   2          {
 183   3            XMClient.Time.Count=0;
 184   3              XMClient.Package.Size=0;
 185   3            if(XMClient.Package.Memory[1]==(IAP_Count&0xFF))
 186   3            {
 187   4              ErrorCount=0;
 188   4              
 189   4              {
 190   5                u8 i;
 191   5                if(IAP_Count>=3)
 192   5                {     
 193   6                  File_crc=CRC32_Xmodem(File_crc,&SaveXmodemData[0],XMODERN_BUFFER_SIZE-5);
 194   6                }         
 195   5                for(i=0;i<128;i++)
 196   5                {
 197   6                  SaveXmodemData[i]=SaveXmodemData[i+128];
 198   6                  SaveXmodemData[i+128]=XMClient.Package.Memory[3+i];
 199   6                }
 200   5                }       
 201   4              
 202   4              
 203   4              crc=CRC16_Xmodem(crc,&XMClient.Package.Memory[3],XMODERN_BUFFER_SIZE-5);
 204   4              if((crc-XMClient.Package.Memory[XMODERN_BUFFER_SIZE-2]*0x100-XMClient.Package.Memory[XMODERN_BUFFER_SI
             -ZE-1])==0)
 205   4              {
 206   5          
 207   5                OTA_Data->PacketNumber=IAP_Count-1;
 208   5                        OTA_Data->Size=XMODERN_BUFFER_SIZE-5;
 209   5                for(IapLen=0;IapLen<OTA_Data->Size;IapLen++)
 210   5                {
 211   6                            OTA_Data->Memory[IapLen]=XMClient.Package.Memory[IapLen+3];
 212   6                }
 213   5                
 214   5                IAP_Count++;
 215   5              }
 216   4              else  //crc 错误
 217   4              {
 218   5                ErrorCount+=2;
 219   5                UART_SendByte(XR_NACK);
 220   5              }
 221   4            }
 222   3            else  //包号错误
 223   3            {
 224   4              ErrorCount+=2;
 225   4              UART_SendByte(XR_NACK);
 226   4            }
 227   3          }
 228   2          
 229   2        }
 230   1        if(ErrorCount>=25)  //错误太多，发送CAN
 231   1        {
 232   2          UART_SendByte(XR_CAN);
 233   2          UART_SendByte(XR_CAN);
 234   2          UART_SendByte(XR_CAN);
 235   2                  
 236   2          XMClient.Package.Size=0;
 237   2          XMClient.State=XS_Error;
 238   2          XMClient.Phase=XP_PackEnd;;
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 5   

 239   2          return XS_Fault;
 240   2        } 
 241   1        return XS_Comm;
 242   1      }
 243          void XmodemClient_ACK(void)
 244          {
 245   1        UART_SendByte(XR_ACK);
 246   1      }
 247          void XmodemClient_ReceiveHandle(u8 Data)
 248          {
 249   1        XMClient.Package.Memory[XMClient.Package.Count]=Data;
 250   1        XMClient.Package.Count++;
 251   1        XMClient.Package.Size++;
 252   1        
 253   1        if((XMClient.Package.Memory[0]==XR_CAN)||(XMClient.Package.Memory[0]==XR_EOT))
 254   1        {
 255   2          XMClient.Package.Count=0;
 256   2        }
 257   1        
 258   1        if(XMClient.Package.Count>=XMODERN_BUFFER_SIZE)
 259   1        {
 260   2          XMClient.Package.Count=0;
 261   2        }
 262   1      }
 263          //====================================================================================================
 264          //====================================================================================================
 265          void  IOT_Uart_Receiver(char Data)
 266          {
 267   1          switch (System.Mode)
 268   1          {
 269   2              case sMIIO_Standby:
 270   2              case sMIIO_Ready:
 271   2              case sMIIO_Fault:
 272   2              MIIO_IAP_InData(Data);
 273   2              break;
 274   2              case sIAP:
 275   2              XmodemClient_ReceiveHandle(Data);
 276   2              break;
 277   2              case sAP:
 278   2              MIIO_IAP_InData(Data); //test
 279   2              break;
 280   2              default:
 281   2              MIIO_IAP_InData(Data);
 282   2              break;
 283   2          }   
 284   1      }
 285          //====================================================================================================
 286          //====================================================================================================
 287          void  IOT_Init(char Select)
 288          {
 289   1              if(Select==0)
 290   1              { 
 291   2                      MIIO_OTA_Init(sMIIO_Model);    //连接平台模式
 292   2              }
 293   1              else
 294   1              { 
 295   2                      MIIO_OTA_Init(sMIIO_Standby);  //直接下载固件模式
 296   2              } 
 297   1      }
 298          //====================================================================================================
 299          //====================================================================================================
 300          IOT_State IOT_Work()
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 6   

 301          {
 302   1        static unsigned char Send_IOT_State=0;
 303   1        
 304   1        char   Net_State=IOT_NORMAL;
 305   1        
 306   1        if((u8)System.Mode>=sMIIO_Model)
 307   1        {
 308   2          if(((u8)System.Mode==sMIIO_Get_down)||(Send_IOT_State>32))
 309   2          {
 310   3                     if(System.TimeCount>=300)  //300mS
 311   3                          {
 312   4                              System.TimeCount=0;
 313   4                              UART_SendString("get_down\r");
 314   4                  Send_IOT_State++;
 315   4                  Send_IOT_State &=0x7F;
 316   4                          }
 317   3                          if(MIIO_IAP.State==MI_Rx)
 318   3                          {
 319   4                              MIIO_IAP.State=MI_Wait;
 320   4                              MIIO_IAP.Buffer.Count=0;
 321   4                              if((u8)System.Mode==sMIIO_Get_down)
 322   4                  {
 323   5                    if(CmpStr(&MIIO_IAP.Buffer.Memory,"down none\r"))
 324   5                    {
 325   6                      UART_SendString("result\r");
 326   6                    }
 327   5                    if(CmpStr(&MIIO_IAP.Buffer.Memory,"down unknown_command\r"))
 328   5                    {
 329   6                      UART_SendString("result\r");
 330   6                    }
 331   5                    if(CmpStr(&MIIO_IAP.Buffer.Memory,"down MIIO_mcu_version_req\r"))
 332   5                    {
 333   6                      UART_SendString("mcu_version 0001\r");
 334   6                    }       
 335   5                    if(CmpStr(&MIIO_IAP.Buffer.Memory,"down get_properties"))
 336   5                    {
 337   6                      UART_SendString("result\r");
 338   6                    }
 339   5                  }
 340   4                              if(CmpStr(&MIIO_IAP.Buffer.Memory,"down update_fw\r"))
 341   4                              {
 342   5                                  Systime_Set(sMIIO_Standby, IAP_TIME_WINDOW); //设置固件升级命令
 343   5                    
 344   5                    Net_State=IOT_GET_FW;  //收到固件升级命令
 345   5                              }               
 346   4                          }
 347   3          }
 348   2          else
 349   2          {
 350   3            if(System.TimeCount>=300)  //300mS
 351   3                 {
 352   4              System.TimeCount=0;
 353   4              Send_IOT_State++;
 354   4               Send_IOT_State &=0x7F;
 355   4                 }
 356   3            switch ((u8)System.Mode)
 357   3            {
 358   4              case sMIIO_Model:
 359   4                      {
 360   5            
 361   5                          miio_result = MIIO_IAP_Cmd("model sasesi.srser.sas01\r", //
 362   5                          "ok",                 //
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 7   

 363   5                          "error",              //
 364   5                          100,                  //
 365   5                          UART_SendString);    //
 366   5                          if (miio_result == MIR_R1)
 367   5                          {
 368   6                              Systime_Set(sMIIO_Ble_config, IAP_TIME_WINDOW);
 369   6                          }
 370   5                          break;
 371   5              }
 372   4              case sMIIO_Ble_config:
 373   4                      {
 374   5                          miio_result = MIIO_IAP_Cmd("ble_config set 156 0001\r", //
 375   5                          "ok",                 //
 376   5                          "error",              //
 377   5                          100,                  //
 378   5                          UART_SendString);    //
 379   5                          if (miio_result == MIR_R1)
 380   5                          {
 381   6                              Systime_Set(sMIIO_Mcu_version, IAP_TIME_WINDOW);
 382   6                          }
 383   5                          break;
 384   5              } 
 385   4              case sMIIO_Mcu_version:
 386   4                      {
 387   5                          miio_result = MIIO_IAP_Cmd("mcu_version 0001\r", //
 388   5                          "ok",                 //
 389   5                          "error",              //
 390   5                          100,                  //
 391   5                          UART_SendString);    //
 392   5                          if (miio_result == MIR_R1)
 393   5                          {
 394   6                              Systime_Set(sMIIO_Get_down, IAP_TIME_WINDOW);
 395   6                              MIIO_IAP.Time.Count=0;
 396   6                          }
 397   5                          break;
 398   5              } 
 399   4              default:
 400   4                System.Mode = sMIIO_Model;
 401   4                break;
 402   4            }       
 403   3          }
 404   2        }
 405   1        return  Net_State;
 406   1      }
 407          //====================================================================================================
 408          //====================================================================================================
 409          void OTA_FirmwareDownload(IAPDATA_INFO *IAP_Pack)
 410          {
 411   1              switch ((u8)System.Mode)
 412   1              {
 413   2                  case sMIIO_Standby:    //发送升级请求
 414   2                      miio_result = MIIO_IAP_Cmd("get_down\r",     //
 415   2                      "down update_fw", //
 416   2                      "down none",      //
 417   2                      100,              //
 418   2                      UART_SendString);
 419   2                      if (miio_result == MIR_R1) // MIIO need update
 420   2                      {
 421   3                          Systime_Set(sMIIO_Ready, IAP_TIME_BOOT);
 422   3                      }
 423   2                      break;
 424   2                  case sMIIO_Ready:     //应答IOT平台，准备接收固件
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 8   

 425   2                      miio_result = MIIO_IAP_Cmd("result \"ready\"\r", //
 426   2                      "ok",                 //
 427   2                      "error",              //
 428   2                      100,                  //
 429   2                      UART_SendString);    //
 430   2                      if (miio_result == MIR_R1)
 431   2                      {
 432   3                          Systime_Set(sIAP, IAP_TIME_BOOT);
 433   3                      }
 434   2                      break;
 435   2                  case sIAP:       //下载固件数据
 436   2                      System.TimeCount=0;
 437   2              
 438   2              if((IAP_Pack->State==OTA_IAPWRITED)&&(IAP_Pack->Size==0)) //完成一包数据接收,且写入IAP完成
 439   2              {
 440   3                XmodemClient_ACK();            //回应IOT平台ACK,准备接收下一包数据
 441   3                IAP_Pack->State=OTA_READY;
 442   3              }
 443   2              if(IAP_Pack->State==OTA_FAULT)      //IAP写入出错
 444   2              {
 445   3                IAP_Pack->State=OTA_READY;
 446   3                XS_Result = XS_Fault;
 447   3              }
 448   2            
 449   2            
 450   2                      XS_Result = XmodemClient_Proess(IAP_Pack);//(&IAP_Pack);  //下载固件，存放于IAP_Pack
 451   2          
 452   2                      if (XS_Result == XS_Finish)        //下载进程结束
 453   2                      {
 454   3                              if(FileCrcerror==0)         
 455   3                  {
 456   4                    AppCompleteCheck();                         //下载成功，检查代码版本并copy到APP区
 457   4                    IAP_Pack->State=OTA_COMPLETE;
 458   4                        XmodemClient_ACK();
 459   4                  }
 460   3                  else
 461   3                  {
 462   4                    IAP_Pack->State=OTA_FAULT;
 463   4                    MIIO_IAP.ReSendCount = 0;
 464   4                    Systime_Set(sMIIO_Fault, IAP_TIME_BOOTFIAL);
 465   4                    XmodemClient_ACK();
 466   4                  }         
 467   3                      }
 468   2                      else if (XS_Result == XS_Fault)
 469   2                      {
 470   3                          MIIO_IAP.ReSendCount = 0;
 471   3                          Systime_Set(sMIIO_Fault, IAP_TIME_BOOTFIAL);
 472   3                      }
 473   2                      else
 474   2                      {
 475   3                          Systime_Set(sIAP, IAP_TIME_BOOT);
 476   3                      }
 477   2                      break;
 478   2                  case sAP:   //跳转到运行区运行
 479   2                      { 
 480   3                      break;
 481   3                  }
 482   2                  case sMIIO_Fault:  //出错处理
 483   2                      {
 484   3                          unsigned char i;
 485   3                          for(i=0;i<10;i++)
 486   3                          {
C51 COMPILER V9.59.0.0   MIIO_OPERATE                                                      03/23/2024 09:11:11 PAGE 9   

 487   4                              UART_SendString("mcu_boot fail\r");
 488   4                              System.TimeCount=0;
 489   4                              while(System.TimeCount<200)
 490   4                              {
 491   5                                  WDTCON |=0X10;
 492   5                              }
 493   4                          }
 494   3                          System.Mode = sMIIO_Standby;
 495   3                MIIO_OTA_Init(sMIIO_Standby);  //直接下载固件模式
 496   3                          break;
 497   3                  }
 498   2                  default:
 499   2                   
 500   2                      break;
 501   2              }   
 502   1      }
 503          //====================================================================================================
 504          //====================================================================================================
 505          void Systime_Count()
 506          {
 507   1        System.TimeCount++;
 508   1        XMClient.Time.Count++;
 509   1        MIIO_IAP.Time.Count++;
 510   1      }
 511          //====================================================================================================
 512          //====================================================================================================
 513          void Systime_Set(SystemMode_t mode, u32 TimeLimit)
 514          {
 515   1          System.Mode      = mode;
 516   1          System.TimeCount = 0;
 517   1          System.TimeLimit = TimeLimit;
 518   1          MIIO_IAP.State=MI_Wait;
 519   1      }
 520          //====================================================================================================
 521          //====================================================================================================
 522          void MIIO_OTA_Init(SystemMode_t mode)
 523          {
 524   1        XmodemClient_ModeInit(XM_CRC,XMClient_Buffer);
 525   1          Systime_Set(mode, IAP_TIME_WINDOW); 
 526   1      }
 527          //====================================================================================================
 528          //====================================================================================================


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2595    ----
   CONSTANT SIZE    =    248    ----
   XDATA SIZE       =   1200      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
