C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_ADCOLLECT
OBJECT MODULE PLACED IN ..\Output\bsp_ADCollect.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Apps\bsp_ADCollect.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE INTVECTOR(0X1
                    -000) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..\Apps;..\Apps
                    -) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\bsp_ADCollect.lst) TABS(2) OBJECT(..\Output\bsp_ADCollect.obj)

line level    source

   1          #include "globe.h"
   2          #include  "bsp_ADCollect.h"
   3          
   4          
   5          
   6          #define AD_TO_SELECT_TOP  {}//sADcnt= 0; \
   7                                    //ADC0_ChannelSelect(ADC_POSINPUT_AIN0,ADC_NEGINPUT_AIN0)
   8          
   9          
  10          #define ADCHANAL_GetValue()   ADC_GetConversionValue()
  11          #define ADCHANAL_Select(X)    ADC_ChannelConfig(ADC_CHANNEL_##X,ENABLE);ADC_StartConversion();//ADC0_Chann
             -elSelect(ADC_POSINPUT_AIN##X,ADC_NEGINPUT_AIN##X); 
  12            
  13            
  14          #define AD_COLLECT_ENABLE  {}//ADC0_Enable() 
  15          #define AD_COLLECT_DIASBLE {}//ADC0_Disable() 
  16            
  17          #define AD_CallBACK        {}//ADC0_CallbackRegister(ADC0_CallBack, adc_context)
  18          #define AD_StartConver     {}//ADC0_ConversionStart()
  19            
  20          #define ADXiShu 0.056 
  21          
  22            
  23           
  24          /************************************************************************* 
  25          * 函数名称: sysRuning
  26          * 功能说明: (gAD_Value[0]/4096)*5.2*10 = 52/4096 = 0.0126953125
  27          * 功能说明: 
  28          * 输    入: 无  
  29          * 输    出: 无
  30          *************************************************************************/
  31          
  32          
  33          static u8 sADCnt,gTempAD_Cnt;
  34          
  35          
  36          //unsigned int adc_sum = 0;
  37          
  38          #define ADAverage_CH_Num ADMax
  39          
  40          typedef struct
  41          {
  42              u16 adc_value_max[ADAverage_CH_Num];
  43              u16 adc_value_min[ADAverage_CH_Num];
  44              u32 adc_sum[ADAverage_CH_Num];
  45          
  46          }ST_AD_Aversage;
  47           
  48          ST_AD_Aversage  gstAD_Aversage;
  49          
  50          
  51          
  52          
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 2   

  53          
  54          
  55          
  56          void ChunShuiTDS(void)
  57          {
  58   1        
  59   1      }
  60          
  61          void JieShuiTDS(void)
  62          {
  63   1          
  64   1      }
  65          
  66          void YuanShui_IO_Flip(void)
  67          {
  68   1          P04 = !P04;
  69   1          P02 = !P02;
  70   1      }
  71          
  72          void YuanShui_IO_Flip_1(void)
  73          {
  74   1          P04 = 0;
  75   1          P02 = 1;
  76   1      }
  77          
  78          void YuanShui_IO_Flip_2(void)
  79          {
  80   1          P04 = 1;
  81   1          P02 = 0;
  82   1      }
  83          
  84          void ChunShui_IO_Flip(void)
  85          {
  86   1          P14 = !P14;
  87   1          P25 = !P25;
  88   1      }
  89          
  90          void ChunShui_IO_Flip_1(void)
  91          {
  92   1          P14 = 0;
  93   1          P25 = 1;
  94   1      }
  95          
  96          void ChunShui_IO_Flip_2(void)
  97          {
  98   1          P14 = 1;
  99   1          P25 = 0;
 100   1      }
 101          
 102          void JieShui_IO_Flip(void)
 103          {
 104   1          P26 = !P26;
 105   1          P27 = !P27;
 106   1      }
 107          
 108          void JieShui_IO_Flip_1(void)
 109          {
 110   1          P26 = 0;
 111   1          P27 = 1;
 112   1      }
 113          
 114          void JieShui_IO_Flip_2(void)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 3   

 115          {
 116   1          P26 = 1;
 117   1          P27 = 0;
 118   1      }
 119          
 120          void LouShui_IO_Flip(void)
 121          {
 122   1          P00 = !P00;
 123   1          P01 = !P01;
 124   1      }
 125          
 126          void LouShui_IO_Flip_1(void)
 127          {
 128   1          P00 =  0;
 129   1          P01 =  1;
 130   1      }
 131          
 132          void LouShui_IO_Flip_2(void)
 133          {
 134   1          P00 = 1;
 135   1          P01 = 0;
 136   1      }
 137          
 138          
 139          
 140          #define AD_Cycle 10
 141          void ADCollectProcess(void)
 142          {
 143   1        static u8 sADChanalCnt = 0;
 144   1        static u8 sAD_Step = 0;
 145   1        
 146   1        if(gstADCollect.ADAvergeCnt >=10)
 147   1          return;
 148   1      
 149   1        sADChanalCnt++;
 150   1        
 151   1      #if 1
 152   1        switch(sAD_Step)
 153   1        {
 154   2          case 0:
 155   2            
 156   2            if(sADChanalCnt == 1)
 157   2            {
 158   3              ChunShui_IO_Flip_1();
 159   3            }
 160   2            else if(sADChanalCnt == 3)
 161   2            {
 162   3               ADCHANAL_Select(1);        
 163   3            }
 164   2      
 165   2            else if(sADChanalCnt == 5)
 166   2            {
 167   3              gstADCollect.ChunShui[gstADCollect.ADAvergeCnt] = ADCHANAL_GetValue();  
 168   3            }
 169   2      
 170   2      
 171   2            else if(sADChanalCnt >= AD_Cycle)
 172   2            {
 173   3              sAD_Step++;
 174   3              sADChanalCnt =0;
 175   3              ChunShui_IO_Flip_2();
 176   3              YuanShui_IO_Flip_1();
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 4   

 177   3            }
 178   2            
 179   2             
 180   2          break;  
 181   2      
 182   2          case 1:
 183   2            
 184   2            if(sADChanalCnt == 1)
 185   2            {
 186   3              JieShui_IO_Flip_1();
 187   3              // ChunShui_IO_Flip_1();
 188   3            }
 189   2            else if(sADChanalCnt == 3)
 190   2            {
 191   3               ADCHANAL_Select(3);
 192   3            }
 193   2      
 194   2            else if(sADChanalCnt == 5)
 195   2            {
 196   3              gstADCollect.JieShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();
 197   3            }
 198   2      
 199   2      
 200   2            else if(sADChanalCnt >= AD_Cycle)
 201   2            {
 202   3              sAD_Step++;
 203   3              sADChanalCnt =0;
 204   3              JieShui_IO_Flip_2();
 205   3              //ChunShui_IO_Flip_2();
 206   3              YuanShui_IO_Flip_2();
 207   3            }
 208   2            
 209   2          break;
 210   2      #if 1
 211   2          case 2:
 212   2            if(sADChanalCnt == 1)
 213   2            {
 214   3              LouShui_IO_Flip_1();
 215   3              //ChunShui_IO_Flip_1();
 216   3            }
 217   2            else if(sADChanalCnt == 3)
 218   2            {
 219   3               ADCHANAL_Select(6);
 220   3            }
 221   2      
 222   2            else if(sADChanalCnt == 5)
 223   2            {
 224   3              gstADCollect.LouShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui
 225   3              
 226   3            }
 227   2      
 228   2      
 229   2            else if(sADChanalCnt >= AD_Cycle)
 230   2            {
 231   3              sAD_Step++;
 232   3              sADChanalCnt =0;
 233   3              LouShui_IO_Flip_2();
 234   3              // ChunShui_IO_Flip_2();
 235   3            }
 236   2          break;
 237   2      #endif
 238   2          case 3:
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 5   

 239   2            if(sADChanalCnt == 1)
 240   2            {
 241   3              YuanShui_IO_Flip_1();
 242   3              
 243   3            }
 244   2            else if(sADChanalCnt == 3)
 245   2            {
 246   3               ADCHANAL_Select(7);
 247   3            }
 248   2      
 249   2            else if(sADChanalCnt == 5)
 250   2            {
 251   3              gstADCollect.YuanShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui        
 252   3            }
 253   2      
 254   2      
 255   2            else if(sADChanalCnt >= AD_Cycle)
 256   2            {
 257   3              sAD_Step =0;
 258   3              sADChanalCnt =0;
 259   3              YuanShui_IO_Flip_2();
 260   3              gstADCollect.ADAvergeCnt++;
 261   3            }
 262   2          break;
 263   2      
 264   2          default:
 265   2            break;
 266   2      
 267   2          
 268   2      
 269   2        }
 270   1      #endif
 271   1        
 272   1      }
 273          
 274          
 275          unsigned int adc_get_average(u16 *p)            
 276          {
 277   1        unsigned int adc_value_max = 0;
 278   1        unsigned int adc_value_min = 0xffff;
 279   1        unsigned int adc_sum = 0;
 280   1        unsigned int adc_current = 0;
 281   1        unsigned char i;
 282   1        
 283   1        for(i = 0;i<10;i++)
 284   1        {
 285   2          adc_current = p[i];
 286   2          if(adc_current > adc_value_max)
 287   2          {
 288   3            adc_value_max = adc_current;
 289   3          }
 290   2          if(adc_current < adc_value_min)
 291   2          {
 292   3            adc_value_min = adc_current;
 293   3          }
 294   2          adc_sum = adc_sum + adc_current;
 295   2        }
 296   1        
 297   1        adc_sum = adc_sum - adc_value_min;
 298   1        adc_sum = adc_sum - adc_value_max;
 299   1        adc_sum = adc_sum>>3;
 300   1        return adc_sum;
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 6   

 301   1      }
 302          
 303          #define TDS_100 100
 304          #define TDS_300 300
 305          #define TDS_500 500
 306          #define TDS_1000 1000
 307          
 308          
 309          
 310          void TDS_Calulate(void)
 311          {
 312   1        static u8 sTDS_Calulate =0;
 313   1      
 314   1        
 315   1        
 316   1        
 317   1        if(gstADCollect.ADAvergeCnt < 10)
 318   1        {
 319   2          return;
 320   2        }
 321   1      
 322   1        
 323   1      
 324   1          
 325   1      
 326   1        if(sTDS_Calulate < 5)//TDS每隔500ms检测一次,前面3秒钟AD数据不计算
 327   1        {
 328   2            sTDS_Calulate++;
 329   2            if(sTDS_Calulate < 0)
 330   2            {
 331   3              gstADCollect.ADAvergeCnt = 0;
 332   3            }
 333   2            return;
 334   2        }
 335   1          
 336   1        else
 337   1        { 
 338   2            sTDS_Calulate = 15;
 339   2        }
 340   1          
 341   1      
 342   1        gstADCollect.ADAvergeCnt = 0;
 343   1      
 344   1      
 345   1        gstADCollect.fYuanShui= adc_get_average(gstADCollect.YuanShui);
 346   1      
 347   1        gstADCollect.fChunShui=  adc_get_average(gstADCollect.ChunShui);
 348   1      
 349   1        gstADCollect.fLouShui=    adc_get_average(gstADCollect.LouShui);
 350   1      
 351   1        gstADCollect.fJieShui=     adc_get_average(gstADCollect.JieShui);
 352   1      
 353   1      }
 354          
 355          
 356          
 357          // 计算TDS值的函数
 358          
 359          #include <math.h>
 360          #define ADC_MAX_VALUE 0x0fff
 361          #define ADC_MIN_VALUE 0
 362          
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 7   

 363          
 364          
 365          float adc_to_tds(u16 adc_value, int a,int b) 
 366          {
 367   1        
 368   1          // 将ADC值标准化到0到1之间
 369   1          float normalized_adc = (adc_value  - ADC_MIN_VALUE) / (float)(ADC_MAX_VALUE - ADC_MIN_VALUE);
 370   1          // 应用一次线性拟合
 371   1          float  linear_tds= a * normalized_adc + b;
 372   1      
 373   1          return linear_tds;
 374   1      }
 375          
 376          void test_TDS(u16 D, float *pp)
 377          {
 378   1          //gstADCollect.tds_ChunShui =adc_to_tds(gstADCollect.fChunShui);
 379   1          u16 v = D;
 380   1          
 381   1          float *p =pp; 
 382   1          
 383   1        #if 0
              //    if(gstADCollect.fChunShui <= 753)//20
              //    {
              //        gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,172.4,-3.4);//30
              //    }
                  if(v <= 600)//20
                  {
                      *p = adc_to_tds(v,80,-3);
                  }
              
                  else if(v<= 880)               //1146 50ppm
                  {
                      *p  = adc_to_tds(v,140,-5);//40
                  }
              //    else if(gstADCollect.fChunShui <= 880)
              //    {
              //        gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,200,-6);//40
              //    }
                  else if(v <= 1156)//50ppm
                  {
                      *p= adc_to_tds(v,372,-54);
                  }
              //    else if(gstADCollect.fChunShui <= 1175)
              //    {
              //        gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,232.5,-9.5);//50
              //    }
                  
                  else if(gstADCollect.fChunShui <= 1415)
                  {
                      gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,421.7,-57.9);//85
                  }
                  
                  else if(gstADCollect.fChunShui <= 1820)
                  {
                      gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,897,-225);//110
                  }
                  
                  else if(gstADCollect.fChunShui <= 2020)
                  {
                      gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,1500,-478);//200
                  }
                #else
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 8   

 425   1          
 426   1        #if 0
                  if(v <= 600)//20
                  {
                      *p = adc_to_tds(v,80,-3);
                  }
              
                  else if(v<= 880)               //1146 50ppm
                  {
                      *p  = adc_to_tds(v,140,-5);//40
                  }
                  else if(v <= 1156)//50ppm
                  {
                      //*p   = adc_to_tds(v,200,-9.5);//50
                      *p= adc_to_tds(v,372,-54);
                  }
                  
                  else if(v <= 1356)//100ppm 1226
                  {
                      //*p   = adc_to_tds(v,200,-9.5);//50
                      *p= adc_to_tds(v,1137,-268);
                  }
                  
                  else if(v <= 1610)//200ppm
                  {
                      *p  = adc_to_tds(v,1479,-390);//85
                  }
                  
                  else if(v <= 1820)
                  {
                      
                      *p   = adc_to_tds(v,819,-174);//110
                  }
                  
                  else if(v <= 1820)
                  {
                      
                      *p  = adc_to_tds(v,897,-225);//110
                  }
                  #endif
 465   1          
 466   1              *p  = adc_to_tds(v,205,0);//110
 467   1          #endif
 468   1        }
 469              
 470              
 471          
 472          
 473          void PaiShuiProcess(void)//1S钟运行一次
 474          {
 475   1        static u8 sTDS_Time =0;
 476   1        
 477   1        test_TDS(gstADCollect.fChunShui,&gstADCollect.tds_ChunShui);
 478   1        test_TDS(gstADCollect.fYuanShui,&gstADCollect.tds_YuanShui);
 479   1        
 480   1      //  if(gstADCollect.tds_YuanShui <= 60)
 481   1      //    gstADCollect.tds_YuanShui*=1.5;
 482   1      //  
 483   1      //  else if(gstADCollect.tds_YuanShui <= 333)
 484   1      //    gstADCollect.tds_YuanShui*=3;
 485   1        
 486   1        if(sTDS_Time < 100)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 9   

 487   1          sTDS_Time++;
 488   1      
 489   1        
 490   1        if(sTDS_Time < 100)
 491   1        {
 492   2          if(gstADCollect.fYuanShui >= TDS_100)
 493   2          {
 494   3            KongShuiFa_IO = 1;      
 495   3          }
 496   2      
 497   2          else if(gstADCollect.fYuanShui >= TDS_300)
 498   2          {
 499   3            KongShuiFa_IO = 1;  
 500   3          }
 501   2      
 502   2          else if(gstADCollect.fYuanShui >= TDS_500)
 503   2          {
 504   3            KongShuiFa_IO = 1;  
 505   3          }
 506   2          else//上店10秒内TTDS <100
 507   2          {
 508   3            KongShuiFa_IO = 1;  
 509   3          }
 510   2        }
 511   1      }
 512          
 513          
 514          
 515          #if 0
                if(sADChanalCnt == 1)
                {
                    ChunShui_IO_Flip();
                    ADCHANAL_Select(1);
                    gstADCollect.ChunShui = ADC_GetConversionAverageValue(3);//YuanShui
                    gstADCollect.ChunShui  *= 0.00122;
                    sADChanalCnt = 3;
                }
              
                else if(sADChanalCnt == 3)
                {
                    ADCHANAL_Select(3);
                    gstADCollect.JieShui = ADC_GetConversionAverageValue(3);//ChunShui
                    gstADCollect.JieShui *= 0.00122;
                  
                    JieShui_IO_Flip();
                    
                    sADChanalCnt = 6;
                }
                
                else if(sADChanalCnt == 6)
                {
                    ChunShui_IO_Flip();
                    ADCHANAL_Select(6);
                    gstADCollect.LouShui = ADC_GetConversionAverageValue(3);//JieShui
                    gstADCollect.LouShui  *= 0.00122;
                  
                    LouShui_IO_Flip();
                    
                    sADChanalCnt = 7;
                }
                else if(sADChanalCnt == 7)
                {
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/02/2024 21:10:00 PAGE 10  

                    ADCHANAL_Select(7);
                    gstADCollect.YuanShui = ADC_GetConversionAverageValue(3);// YuanShui LouShui
                    gstADCollect.YuanShui  *= 0.00122;
                  
                    YuanShui_IO_Flip();
                    
                    sADChanalCnt = 1;
                }
                else
                {
                    ADCHANAL_Select(1);
                }
              #endif
 562          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1368    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
