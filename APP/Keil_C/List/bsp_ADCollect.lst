C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_ADCOLLECT
OBJECT MODULE PLACED IN ..\Output\bsp_ADCollect.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Apps\bsp_ADCollect.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE INTVECTOR(0X1
                    -000) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..\Apps;..\Apps
                    -) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\bsp_ADCollect.lst) TABS(2) OBJECT(..\Output\bsp_ADCollect.obj)

line level    source

   1          #include "globe.h"
   2          #include  "bsp_ADCollect.h"
   3          
   4          
   5          
   6          #define AD_TO_SELECT_TOP  {}//sADcnt= 0; \
   7                                    //ADC0_ChannelSelect(ADC_POSINPUT_AIN0,ADC_NEGINPUT_AIN0)
   8          
   9          
  10          #define ADCHANAL_GetValue()   ADC_GetConversionValue()
  11          #define ADCHANAL_Select(X)    ADC_ChannelConfig(ADC_CHANNEL_##X,ENABLE);ADC_StartConversion();//ADC0_Chann
             -elSelect(ADC_POSINPUT_AIN##X,ADC_NEGINPUT_AIN##X); 
  12            
  13            
  14          #define AD_COLLECT_ENABLE  {}//ADC0_Enable() 
  15          #define AD_COLLECT_DIASBLE {}//ADC0_Disable() 
  16            
  17          #define AD_CallBACK        {}//ADC0_CallbackRegister(ADC0_CallBack, adc_context)
  18          #define AD_StartConver     {}//ADC0_ConversionStart()
  19            
  20          #define ADXiShu 0.056 
  21          
  22            
  23           
  24          /************************************************************************* 
  25          * 函数名称: sysRuning
  26          * 功能说明: (gAD_Value[0]/4096)*5.2*10 = 52/4096 = 0.0126953125
  27          * 功能说明: 
  28          * 输    入: 无  
  29          * 输    出: 无
  30          *************************************************************************/
  31          
  32          
  33          static u8 sADCnt,gTempAD_Cnt;
  34          
  35          
  36          //unsigned int adc_sum = 0;
  37          
  38          #define ADAverage_CH_Num ADMax
  39          
  40          typedef struct
  41          {
  42              u16 adc_value_max[ADAverage_CH_Num];
  43              u16 adc_value_min[ADAverage_CH_Num];
  44              u32 adc_sum[ADAverage_CH_Num];
  45          
  46          }ST_AD_Aversage;
  47           
  48          ST_AD_Aversage  gstAD_Aversage;
  49          
  50          
  51          
  52          
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 2   

  53          
  54          
  55          
  56          void ChunShuiTDS(void)
  57          {
  58   1        
  59   1      }
  60          
  61          void JieShuiTDS(void)
  62          {
  63   1          
  64   1      }
  65          
  66          void YuanShui_IO_Flip(void)
  67          {
  68   1          P04 = !P04;
  69   1          P02 = !P02;
  70   1      }
  71          
  72          void YuanShui_IO_Flip_1(void)
  73          {
  74   1          P04 = 0;
  75   1          P02 = 1;
  76   1      }
  77          
  78          void YuanShui_IO_Flip_2(void)
  79          {
  80   1          P04 = 1;
  81   1          P02 = 0;
  82   1      }
  83          
  84          void ChunShui_IO_Flip(void)
  85          {
  86   1          P14 = !P14;
  87   1          P25 = !P25;
  88   1      }
  89          
  90          void ChunShui_IO_Flip_1(void)
  91          {
  92   1          P14 = 0;
  93   1          P25 = 1;
  94   1      }
  95          
  96          void ChunShui_IO_Flip_2(void)
  97          {
  98   1          P14 = 1;
  99   1          P25 = 0;
 100   1      }
 101          
 102          void JieShui_IO_Flip(void)
 103          {
 104   1          P26 = !P26;
 105   1          P27 = !P27;
 106   1      }
 107          
 108          void JieShui_IO_Flip_1(void)
 109          {
 110   1          P26 = 0;
 111   1          P27 = 1;
 112   1      }
 113          
 114          void JieShui_IO_Flip_2(void)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 3   

 115          {
 116   1          P26 = 1;
 117   1          P27 = 0;
 118   1      }
 119          
 120          void LouShui_IO_Flip(void)
 121          {
 122   1          P00 = !P00;
 123   1          P01 = !P01;
 124   1      }
 125          
 126          void LouShui_IO_Flip_1(void)
 127          {
 128   1          P00 =  0;
 129   1          P01 =  1;
 130   1      }
 131          
 132          void LouShui_IO_Flip_2(void)
 133          {
 134   1          P00 = 1;
 135   1          P01 = 0;
 136   1      }
 137          
 138          void TDs_IO_Flip(void)
 139          {
 140   1        P04 = !P04;
 141   1        P02 = !P02;
 142   1        
 143   1        P14 = !P14;
 144   1        P25 = !P25;
 145   1        
 146   1        P26 = !P26;
 147   1        P27 = !P27;
 148   1        
 149   1        P00 = !P00;
 150   1        P01 = !P01;
 151   1      }
 152          
 153          #define AD_Cycle 15
 154          void ADCollectProcess(void)
 155          {
 156   1        static u8 sADChanalCnt = 0;
 157   1        static u8 sAD_Step = 0;
 158   1        
 159   1        if(gstADCollect.ADAvergeCnt >=10)
 160   1          return;
 161   1      
 162   1        sADChanalCnt++;
 163   1        
 164   1      #if 1
 165   1        switch(sAD_Step)
 166   1        {
 167   2          case 0:
 168   2            
 169   2            if(sADChanalCnt == 1)
 170   2            {
 171   3              ChunShui_IO_Flip_1();
 172   3              //LouShui_IO_Flip();
 173   3            }
 174   2            else if(sADChanalCnt == 3)
 175   2            {
 176   3               ADCHANAL_Select(1);
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 4   

 177   3              
 178   3            }
 179   2      
 180   2            else if(sADChanalCnt == 5)
 181   2            {
 182   3              gstADCollect.ChunShui[gstADCollect.ADAvergeCnt] = ADCHANAL_GetValue();  
 183   3              //LouShui_IO_Flip();
 184   3            }
 185   2      
 186   2      
 187   2            else if(sADChanalCnt >= AD_Cycle)
 188   2            {
 189   3              sAD_Step++;
 190   3              sADChanalCnt =0;
 191   3              ChunShui_IO_Flip_2();
 192   3              
 193   3            }
 194   2            
 195   2             
 196   2          break;  
 197   2      
 198   2          case 1:
 199   2            
 200   2            if(sADChanalCnt == 1)
 201   2            {
 202   3              JieShui_IO_Flip_1();
 203   3              //YuanShui_IO_Flip();
 204   3            }
 205   2            else if(sADChanalCnt == 3)
 206   2            {
 207   3               ADCHANAL_Select(3);
 208   3              // YuanShui_IO_Flip();
 209   3            }
 210   2      
 211   2            else if(sADChanalCnt == 5)
 212   2            {
 213   3              gstADCollect.JieShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();
 214   3            }
 215   2      
 216   2      
 217   2            else if(sADChanalCnt >= AD_Cycle)
 218   2            {
 219   3              sAD_Step++;
 220   3              sADChanalCnt =0;
 221   3              JieShui_IO_Flip_1();
 222   3              
 223   3            }
 224   2            
 225   2          break;
 226   2      
 227   2          case 2:
 228   2            if(sADChanalCnt == 1)
 229   2            {
 230   3              LouShui_IO_Flip_1();
 231   3              //ChunShui_IO_Flip();
 232   3            }
 233   2            else if(sADChanalCnt == 3)
 234   2            {
 235   3               ADCHANAL_Select(6);;
 236   3            }
 237   2      
 238   2            else if(sADChanalCnt == 5)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 5   

 239   2            {
 240   3              gstADCollect.LouShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui
 241   3              
 242   3            }
 243   2      
 244   2      
 245   2            else if(sADChanalCnt >= AD_Cycle)
 246   2            {
 247   3              sAD_Step++;
 248   3              sADChanalCnt =0;
 249   3              LouShui_IO_Flip_1();
 250   3            }
 251   2          break;
 252   2      
 253   2          case 3:
 254   2            if(sADChanalCnt == 1)
 255   2            {
 256   3              YuanShui_IO_Flip_1();
 257   3            }
 258   2            else if(sADChanalCnt == 3)
 259   2            {
 260   3               ADCHANAL_Select(7);
 261   3            }
 262   2      
 263   2            else if(sADChanalCnt == 5)
 264   2            {
 265   3              gstADCollect.YuanShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui        
 266   3            }
 267   2      
 268   2      
 269   2            else if(sADChanalCnt >= AD_Cycle)
 270   2            {
 271   3              sAD_Step =0;
 272   3              sADChanalCnt =0;
 273   3              YuanShui_IO_Flip_1();
 274   3              gstADCollect.ADAvergeCnt++;
 275   3            }
 276   2          break;
 277   2      
 278   2          default:
 279   2            break;
 280   2      
 281   2          
 282   2      
 283   2        }
 284   1      #endif
 285   1        
 286   1      }
 287          
 288          
 289          unsigned int adc_get_average(u16 *p)            
 290          {
 291   1        unsigned int adc_value_max = 0;
 292   1        unsigned int adc_value_min = 0xffff;
 293   1        unsigned int adc_sum = 0;
 294   1        unsigned int adc_current = 0;
 295   1        unsigned char i;
 296   1        
 297   1        for(i = 0;i<10;i++)
 298   1        {
 299   2          adc_current = p[i];
 300   2          if(adc_current > adc_value_max)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 6   

 301   2          {
 302   3            adc_value_max = adc_current;
 303   3          }
 304   2          if(adc_current < adc_value_min)
 305   2          {
 306   3            adc_value_min = adc_current;
 307   3          }
 308   2          adc_sum = adc_sum + adc_current;
 309   2        }
 310   1        
 311   1        adc_sum = adc_sum - adc_value_min;
 312   1        adc_sum = adc_sum - adc_value_max;
 313   1        adc_sum = adc_sum>>3;
 314   1        return adc_sum;
 315   1      }
 316          
 317          #define TDS_100 1
 318          #define TDS_300 1
 319          #define TDS_500 1
 320          #define TDS_1000 1
 321          
 322          void TDS_Calulate(void)
 323          {
 324   1        static u8 sTDS_Calulate =0;
 325   1        
 326   1        
 327   1        if(gstADCollect.ADAvergeCnt < 10)
 328   1        {
 329   2          return;
 330   2        }
 331   1      
 332   1        
 333   1      
 334   1          
 335   1      
 336   1        if(sTDS_Calulate < 5)//TDS每隔500ms检测一次
 337   1        {
 338   2            sTDS_Calulate++;
 339   2            return;
 340   2        }
 341   1          
 342   1        else
 343   1        { 
 344   2            sTDS_Calulate =0;
 345   2        }
 346   1          
 347   1      
 348   1        gstADCollect.ADAvergeCnt = 0;
 349   1      
 350   1         gstADCollect.fYuanShui= adc_get_average(gstADCollect.YuanShui);
 351   1      
 352   1        gstADCollect.fChunShui=  adc_get_average(gstADCollect.ChunShui);
 353   1      
 354   1        gstADCollect.fLouShui=    adc_get_average(gstADCollect.LouShui);
 355   1      
 356   1        gstADCollect.fJieShui=     adc_get_average(gstADCollect.JieShui);
 357   1      
 358   1      }
 359          
 360          // 计算TDS值的函数
 361          
 362          #include <math.h>
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 7   

 363          #define ADC_MAX_VALUE 0x0fff
 364          #define ADC_MIN_VALUE 0
 365          
 366            //float e  = -100;
 367          
 368            float c = 4/917; // 根据实际情况调整
 369          
 370          
 371          float adc_to_tds(u16 adc_value, int a,int b) 
 372          {
 373   1        
 374   1        
 375   1        
 376   1       // 根据实际的ADC参数调整下面的系数
 377   1      // const float a = 232.5; // 根据实际情况调整
 378   1      // const float b = -15.6; // 根据实际情况调整
 379   1       //const float d = -5.464; // 根据实际情况调整
 380   1          // 将ADC值标准化到0到1之间
 381   1          float normalized_adc = (adc_value  - ADC_MIN_VALUE) / (float)(ADC_MAX_VALUE - ADC_MIN_VALUE);
 382   1          // 应用一次线性拟合
 383   1          float  linear_tds= a * normalized_adc + b;
 384   1       
 385   1         /* 根据实际情况，可能需要应用非线性拟合
 386   1          float nonlinear_tds = c * pow(linear_tds, 2) + d * linear_tds +464;
 387   1        */
 388   1          // linear_tds = c * pow(linear_tds, 2) + c* linear_tds -46;
 389   1          return linear_tds;
 390   1      }
 391          
 392          void test_TDS(void)
 393          {
 394   1          //gstADCollect.tds_ChunShui =adc_to_tds(gstADCollect.fChunShui);
 395   1          if(gstADCollect.fChunShui <= 753)//20
 396   1          {
 397   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,172.4,-3.4);//30
 398   2          }
 399   1          
 400   1          else if(gstADCollect.fChunShui <= 880)
 401   1          {
 402   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,200,-6);//40
 403   2          }
 404   1          else if(gstADCollect.fChunShui <= 1175)
 405   1          {
 406   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,232.5,-9.5);//50
 407   2          }
 408   1          
 409   1          else if(gstADCollect.fChunShui <= 1415)
 410   1          {
 411   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,421.7,-57.9);//85
 412   2          }
 413   1          
 414   1          else if(gstADCollect.fChunShui <= 1820)
 415   1          {
 416   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,897,-225);//110
 417   2          }
 418   1          
 419   1          else if(gstADCollect.fChunShui <= 2020)
 420   1          {
 421   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,1500,-478);//110
 422   2          }
 423   1          
 424   1          else 
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 8   

 425   1          {
 426   2              gstADCollect.tds_ChunShui  = adc_to_tds(gstADCollect.fChunShui,2000,-704);//200
 427   2          }
 428   1      }
 429          
 430          void PaiShuiProcess(void)//1S钟运行一次
 431          {
 432   1        static u8 sTDS_Time =0;
 433   1        
 434   1        test_TDS();
 435   1      
 436   1        if(sTDS_Time < 100)
 437   1          sTDS_Time++;
 438   1      
 439   1        
 440   1        if(sTDS_Time < 100)
 441   1        {
 442   2          if(gstADCollect.fYuanShui >= TDS_100)
 443   2          {
 444   3            KongShuiFa_IO = 1;      
 445   3          }
 446   2      
 447   2          else if(gstADCollect.fYuanShui >= TDS_300)
 448   2          {
 449   3            KongShuiFa_IO = 1;  
 450   3          }
 451   2      
 452   2          else if(gstADCollect.fYuanShui >= TDS_500)
 453   2          {
 454   3            KongShuiFa_IO = 1;  
 455   3          }
 456   2          else//上店10秒内TTDS <100
 457   2          {
 458   3            KongShuiFa_IO = 1;  
 459   3          }
 460   2        }
 461   1      }
 462          
 463          
 464          
 465          #if 0
                if(sADChanalCnt == 1)
                {
                    ChunShui_IO_Flip();
                    ADCHANAL_Select(1);
                    gstADCollect.ChunShui = ADC_GetConversionAverageValue(3);//YuanShui
                    gstADCollect.ChunShui  *= 0.00122;
                    sADChanalCnt = 3;
                }
              
                else if(sADChanalCnt == 3)
                {
                    ADCHANAL_Select(3);
                    gstADCollect.JieShui = ADC_GetConversionAverageValue(3);//ChunShui
                    gstADCollect.JieShui *= 0.00122;
                  
                    JieShui_IO_Flip();
                    
                    sADChanalCnt = 6;
                }
                
                else if(sADChanalCnt == 6)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     03/28/2024 21:58:58 PAGE 9   

                {
                    ChunShui_IO_Flip();
                    ADCHANAL_Select(6);
                    gstADCollect.LouShui = ADC_GetConversionAverageValue(3);//JieShui
                    gstADCollect.LouShui  *= 0.00122;
                  
                    LouShui_IO_Flip();
                    
                    sADChanalCnt = 7;
                }
                else if(sADChanalCnt == 7)
                {
                    ADCHANAL_Select(7);
                    gstADCollect.YuanShui = ADC_GetConversionAverageValue(3);// YuanShui LouShui
                    gstADCollect.YuanShui  *= 0.00122;
                  
                    YuanShui_IO_Flip();
                    
                    sADChanalCnt = 1;
                }
                else
                {
                    ADCHANAL_Select(1);
                }
              #endif
 512          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1540    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     54    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
