C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BSP_ADCOLLECT
OBJECT MODULE PLACED IN ..\Output\bsp_ADCollect.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Apps\bsp_ADCollect.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE INTVECTOR(0X1
                    -000) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..\Apps;..\Apps
                    -) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\bsp_ADCollect.lst) TABS(2) OBJECT(..\Output\bsp_ADCollect.obj)

line level    source

   1          #include "globe.h"
   2          #include  "bsp_ADCollect.h"
   3          
   4          
   5          
   6          #define AD_TO_SELECT_TOP  {}//sADcnt= 0; \
   7                                    //ADC0_ChannelSelect(ADC_POSINPUT_AIN0,ADC_NEGINPUT_AIN0)
   8          
   9          
  10          #define ADCHANAL_GetValue()   ADC_GetConversionValue()
  11          #define ADCHANAL_Select(X)    ADC_ChannelConfig(ADC_CHANNEL_##X,ENABLE);ADC_StartConversion();//ADC0_Chann
             -elSelect(ADC_POSINPUT_AIN##X,ADC_NEGINPUT_AIN##X); 
  12            
  13            
  14          #define AD_COLLECT_ENABLE  {}//ADC0_Enable() 
  15          #define AD_COLLECT_DIASBLE {}//ADC0_Disable() 
  16            
  17          #define AD_CallBACK        {}//ADC0_CallbackRegister(ADC0_CallBack, adc_context)
  18          #define AD_StartConver     {}//ADC0_ConversionStart()
  19            
  20          #define ADXiShu 0.056 
  21          
  22            
  23           
  24          /************************************************************************* 
  25          * 函数名称: sysRuning
  26          * 功能说明: (gAD_Value[0]/4096)*5.2*10 = 52/4096 = 0.0126953125
  27          * 功能说明: 
  28          * 输    入: 无  
  29          * 输    出: 无
  30          *************************************************************************/
  31          
  32          
  33          static u8 sADCnt,gTempAD_Cnt;
  34          
  35          
  36          //unsigned int adc_sum = 0;
  37          
  38          #define ADAverage_CH_Num ADMax
  39          
  40          typedef struct
  41          {
  42              u16 adc_value_max[ADAverage_CH_Num];
  43              u16 adc_value_min[ADAverage_CH_Num];
  44              u32 adc_sum[ADAverage_CH_Num];
  45          
  46          }ST_AD_Aversage;
  47           
  48          ST_AD_Aversage  gstAD_Aversage;
  49          
  50          
  51          
  52          
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 2   

  53          
  54          
  55          
  56          void ChunShuiTDS(void)
  57          {
  58   1        
  59   1      }
  60          
  61          void JieShuiTDS(void)
  62          {
  63   1          
  64   1      }
  65          
  66          void YuanShui_IO_Flip(void)
  67          {
  68   1          P04 = !P04;
  69   1          P02 = !P02;
  70   1      }
  71          
  72          void YuanShui_IO_Flip_1(void)
  73          {
  74   1          P04 = 0;
  75   1          P02 = 1;
  76   1      }
  77          
  78          void YuanShui_IO_Flip_2(void)
  79          {
  80   1          P04 = 1;
  81   1          P02 = 0;
  82   1      }
  83          
  84          void ChunShui_IO_Flip(void)
  85          {
  86   1          P14 = !P14;
  87   1          P25 = !P25;
  88   1      }
  89          
  90          void ChunShui_IO_Flip_1(void)
  91          {
  92   1          P14 = 0;
  93   1          P25 = 1;
  94   1      }
  95          
  96          void ChunShui_IO_Flip_2(void)
  97          {
  98   1          P14 = 1;
  99   1          P25 = 0;
 100   1      }
 101          
 102          void JieShui_IO_Flip(void)
 103          {
 104   1          P26 = !P26;
 105   1          P27 = !P27;
 106   1      }
 107          
 108          void JieShui_IO_Flip_1(void)
 109          {
 110   1          P26 = 0;
 111   1          P27 = 1;
 112   1      }
 113          
 114          void JieShui_IO_Flip_2(void)
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 3   

 115          {
 116   1          P26 = 1;
 117   1          P27 = 0;
 118   1      }
 119          
 120          void LouShui_IO_Flip(void)
 121          {
 122   1          P00 = !P00;
 123   1          P01 = !P01;
 124   1      }
 125          
 126          void LouShui_IO_Flip_1(void)
 127          {
 128   1          P00 =  0;
 129   1          P01 =  1;
 130   1      }
 131          
 132          void LouShui_IO_Flip_2(void)
 133          {
 134   1          P00 = 1;
 135   1          P01 = 0;
 136   1      }
 137          
 138          
 139          
 140          #define AD_Cycle 10
 141          void ADCollectProcess(void)
 142          {
 143   1        static u8 sADChanalCnt = 0;
 144   1        static u8 sAD_Step = 0;
 145   1        
 146   1        if(gstADCollect.ADAvergeCnt >=10)
 147   1          return;
 148   1      
 149   1        sADChanalCnt++;
 150   1        
 151   1      #if 1
 152   1        switch(sAD_Step)
 153   1        {
 154   2          case 0:
 155   2            
 156   2            if(sADChanalCnt == 1)
 157   2            {
 158   3              ChunShui_IO_Flip_1();
 159   3            }
 160   2            else if(sADChanalCnt == 3)
 161   2            {
 162   3               ADCHANAL_Select(1);        
 163   3            }
 164   2      
 165   2            else if(sADChanalCnt == 5)
 166   2            {
 167   3              gstADCollect.ChunShui[gstADCollect.ADAvergeCnt] = ADCHANAL_GetValue();  
 168   3            }
 169   2      
 170   2      
 171   2            else if(sADChanalCnt >= AD_Cycle)
 172   2            {
 173   3              sAD_Step++;
 174   3              sADChanalCnt =0;
 175   3              ChunShui_IO_Flip_2();
 176   3              YuanShui_IO_Flip_1();
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 4   

 177   3            }
 178   2            
 179   2             
 180   2          break;  
 181   2      
 182   2          case 1:
 183   2            
 184   2            if(sADChanalCnt == 1)
 185   2            {
 186   3              JieShui_IO_Flip_1();
 187   3              // ChunShui_IO_Flip_1();
 188   3            }
 189   2            else if(sADChanalCnt == 3)
 190   2            {
 191   3               ADCHANAL_Select(3);
 192   3            }
 193   2      
 194   2            else if(sADChanalCnt == 5)
 195   2            {
 196   3              gstADCollect.JieShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();
 197   3            }
 198   2      
 199   2      
 200   2            else if(sADChanalCnt >= AD_Cycle)
 201   2            {
 202   3              sAD_Step++;
 203   3              sADChanalCnt =0;
 204   3              JieShui_IO_Flip_2();
 205   3              //ChunShui_IO_Flip_2();
 206   3              YuanShui_IO_Flip_2();
 207   3            }
 208   2            
 209   2          break;
 210   2      #if 1
 211   2          case 2:
 212   2            if(sADChanalCnt == 1)
 213   2            {
 214   3              LouShui_IO_Flip_1();
 215   3              //ChunShui_IO_Flip_1();
 216   3            }
 217   2            else if(sADChanalCnt == 3)
 218   2            {
 219   3               ADCHANAL_Select(6);
 220   3            }
 221   2      
 222   2            else if(sADChanalCnt == 5)
 223   2            {
 224   3              gstADCollect.LouShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui
 225   3              
 226   3            }
 227   2      
 228   2      
 229   2            else if(sADChanalCnt >= AD_Cycle)
 230   2            {
 231   3              sAD_Step++;
 232   3              sADChanalCnt =0;
 233   3              LouShui_IO_Flip_2();
 234   3              // ChunShui_IO_Flip_2();
 235   3            }
 236   2          break;
 237   2      #endif
 238   2          case 3:
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 5   

 239   2            if(sADChanalCnt == 1)
 240   2            {
 241   3              YuanShui_IO_Flip_1();
 242   3              
 243   3            }
 244   2            else if(sADChanalCnt == 3)
 245   2            {
 246   3               ADCHANAL_Select(7);
 247   3            }
 248   2      
 249   2            else if(sADChanalCnt == 5)
 250   2            {
 251   3              gstADCollect.YuanShui[gstADCollect.ADAvergeCnt]  = ADCHANAL_GetValue();// YuanShui        
 252   3            }
 253   2      
 254   2      
 255   2            else if(sADChanalCnt >= AD_Cycle)
 256   2            {
 257   3              sAD_Step =0;
 258   3              sADChanalCnt =0;
 259   3              YuanShui_IO_Flip_2();
 260   3              gstADCollect.ADAvergeCnt++;
 261   3            }
 262   2          break;
 263   2      
 264   2          default:
 265   2            break;
 266   2      
 267   2          
 268   2      
 269   2        }
 270   1      #endif
 271   1        
 272   1      }
 273          
 274          
 275          unsigned int adc_get_average(u16 *p)            
 276          {
 277   1        unsigned int adc_value_max = 0;
 278   1        unsigned int adc_value_min = 0xffff;
 279   1        unsigned int adc_sum = 0;
 280   1        unsigned int adc_current = 0;
 281   1        unsigned char i;
 282   1        
 283   1        for(i = 0;i<10;i++)
 284   1        {
 285   2          adc_current = p[i];
 286   2          if(adc_current > adc_value_max)
 287   2          {
 288   3            adc_value_max = adc_current;
 289   3          }
 290   2          if(adc_current < adc_value_min)
 291   2          {
 292   3            adc_value_min = adc_current;
 293   3          }
 294   2          adc_sum = adc_sum + adc_current;
 295   2        }
 296   1        
 297   1        adc_sum = adc_sum - adc_value_min;
 298   1        adc_sum = adc_sum - adc_value_max;
 299   1        adc_sum = adc_sum>>3;
 300   1        return adc_sum;
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 6   

 301   1      }
 302          
 303          
 304          
 305          
 306          
 307          void TDS_Calulate(void)
 308          {
 309   1        static u8 sTDS_Calulate =0;
 310   1      
 311   1        
 312   1        
 313   1        
 314   1        if(gstADCollect.ADAvergeCnt < 10)
 315   1        {
 316   2          return;
 317   2        }
 318   1      
 319   1        
 320   1      
 321   1          
 322   1      
 323   1        if(sTDS_Calulate < 5)//TDS每隔500ms检测一次,前面3秒钟AD数据不计算
 324   1        {
 325   2            sTDS_Calulate++;
 326   2            if(sTDS_Calulate < 0)
 327   2            {
 328   3              gstADCollect.ADAvergeCnt = 0;
 329   3            }
 330   2            return;
 331   2        }
 332   1          
 333   1        else
 334   1        { 
 335   2            sTDS_Calulate = 15;
 336   2        }
 337   1          
 338   1      
 339   1        gstADCollect.ADAvergeCnt = 0;
 340   1      
 341   1      
 342   1        gstADCollect.fYuanShui= adc_get_average(gstADCollect.YuanShui);
 343   1      
 344   1        gstADCollect.fChunShui=  adc_get_average(gstADCollect.ChunShui);
 345   1      
 346   1        gstADCollect.fLouShui=    adc_get_average(gstADCollect.LouShui);
 347   1      
 348   1        gstADCollect.fJieShui=     adc_get_average(gstADCollect.JieShui);
 349   1      
 350   1      }
 351          
 352          
 353          
 354          // 计算TDS值的函数
 355          
 356          #include <math.h>
 357          #define ADC_MAX_VALUE 0x0fff
 358          #define ADC_MIN_VALUE 0
 359          
 360          
 361          
 362          float adc_to_tds(u16 adc_value, int a,int b) 
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 7   

 363          {
 364   1        
 365   1          // 将ADC值标准化到0到1之间
 366   1          float normalized_adc = (adc_value  - ADC_MIN_VALUE) / (float)(ADC_MAX_VALUE - ADC_MIN_VALUE);
 367   1          // 应用一次线性拟合
 368   1          float  linear_tds= a * normalized_adc + b;
 369   1      
 370   1          return linear_tds;
 371   1      }
 372          
 373          #define _PPm_1step   377//纯进水
 374          #define _PPm_2step   950//50ppm
 375          #define _PPm_3step   1020//88ppm
 376          #define _PPm_4step   1191//113ppm
 377          void test_TDS(u16 D, float *pp)
 378          {
 379   1          //gstADCollect.tds_ChunShui =adc_to_tds(gstADCollect.fChunShui);
 380   1          u16 v = D;
 381   1          
 382   1          float *p =pp; 
 383   1          
 384   1          if(p == &gstADCollect.tds_ChunShui)
 385   1          {
 386   2              if( v <= _PPm_1step )//ppm 6 357
 387   2              {
 388   3                    *p = adc_to_tds(v,70,0);
 389   3              }
 390   2              
 391   2      
 392   2              else if(v<= _PPm_2step)              //950 50ppm
 393   2              {
 394   3                  *p  = adc_to_tds(v,216,0);
 395   3              }
 396   2              
 397   2              else if(v <= _PPm_3step)//88ppm 1020
 398   2              {
 399   3                  *p  = adc_to_tds(v,216,(v-_PPm_2step)*0.3);//40
 400   3              }
 401   2            
 402   2              else if(v <= _PPm_4step)//113ppm 1091
 403   2              {
 404   3                  *p= adc_to_tds(v,424,0);
 405   3              }
 406   2              else
 407   2              {
 408   3                    *p= adc_to_tds(v,500,(v-_PPm_4step)*0.5);///*p  = adc_to_tds(v,1479,-390);//85
 409   3              }
 410   2      //        else if(v <= 1356)//100ppm 1226
 411   2      //        {
 412   2      //            //*p   = adc_to_tds(v,200,-9.5);//50
 413   2      //            *p= adc_to_tds(v,1137,-268);
 414   2      //        }
 415   2              
 416   2      //        else if(v <= 1610)//200ppm
 417   2      //        {
 418   2      //            *p  = adc_to_tds(v,1479,-390);//85
 419   2      //        }
 420   2      //        
 421   2      //        else if(v <= 1820)
 422   2      //        {
 423   2      //            
 424   2      //            *p   = adc_to_tds(v,819,-174);//110
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 8   

 425   2      //        }
 426   2      //        
 427   2      //        else if(v <= 1820)
 428   2      //        {
 429   2      //            
 430   2      //            *p  = adc_to_tds(v,897,-225);//110
 431   2      //        }
 432   2          }
 433   1      
 434   1          else if(p == &gstADCollect.tds_YuanShui)
 435   1          {
 436   2            if(v< 2225)//ppm 108 ad:2225
 437   2            {
 438   3                  *p  = adc_to_tds(v,205,0);//110
 439   3            }
 440   2            
 441   2            
 442   2            else if(v< 3090)//ppm 299 3087
 443   2            {
 444   3                *p  = adc_to_tds(v,907,-385);//110
 445   3            
 446   3            }
 447   2            
 448   2            else if(v< 3545)//ppm 496 3535
 449   2            {
 450   3                *p  = adc_to_tds(v,1880,-1117);//110
 451   3            
 452   3            }
 453   2            
 454   2            else//ppm 1000 3835
 455   2            {
 456   3                *p  = adc_to_tds(v,6880,-5443);//110
 457   3            }
 458   2          }
 459   1      
 460   1          else
 461   1          {
 462   2              if(v<= 880)              //1146 50ppm
 463   2              {
 464   3                  *p  = adc_to_tds(v,140,-5);//40
 465   3              }
 466   2              else if(v <= 1156)//50ppm
 467   2              {
 468   3                  //*p   = adc_to_tds(v,200,-9.5);//50
 469   3                  *p= adc_to_tds(v,372,-54);
 470   3              }
 471   2              
 472   2              else if(v <= 1356)//100ppm 1226
 473   2              {
 474   3                  //*p   = adc_to_tds(v,200,-9.5);//50
 475   3                  *p= adc_to_tds(v,1137,-268);
 476   3              }
 477   2              
 478   2              else if(v <= 1610)//200ppm
 479   2              {
 480   3                  *p  = adc_to_tds(v,1479,-390);//85
 481   3              }
 482   2              
 483   2              else if(v <= 1820)
 484   2              {
 485   3                  
 486   3                  *p   = adc_to_tds(v,819,-174);//110
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 9   

 487   3              }
 488   2              
 489   2              else if(v <= 1820)
 490   2              {
 491   3                  
 492   3                  *p  = adc_to_tds(v,897,-225);//110
 493   3              }
 494   2          }
 495   1          
 496   1        }
 497          
 498            void TDS_Select(u16 D, float *pp)
 499          {
 500   1          //gstADCollect.tds_ChunShui =adc_to_tds(gstADCollect.fChunShui);
 501   1          u16 v = D;
 502   1          
 503   1          float *p =pp; 
 504   1          
 505   1        #if 0
                  if(v <= 600)//20
                  {
                      *p = adc_to_tds(v,80,-3);
                  }
              
                  else if(v<= 880)               //1146 50ppm
                  {
                      *p  = adc_to_tds(v,140,-5);//40
                  }
                  else if(v <= 1156)//50ppm
                  {
                      //*p   = adc_to_tds(v,200,-9.5);//50
                      *p= adc_to_tds(v,372,-54);
                  }
                  
                  else if(v <= 1356)//100ppm 1226
                  {
                      //*p   = adc_to_tds(v,200,-9.5);//50
                      *p= adc_to_tds(v,1137,-268);
                  }
                  
                  else if(v <= 1610)//200ppm
                  {
                      *p  = adc_to_tds(v,1479,-390);//85
                  }
                  
                  else if(v <= 1820)
                  {
                      
                      *p   = adc_to_tds(v,819,-174);//110
                  }
                  
                  else if(v <= 1820)
                  {
                      
                      *p  = adc_to_tds(v,897,-225);//110
                  }
                  #endif
 544   1          
 545   1              *p  = adc_to_tds(v,205,0);//110
 546   1      
 547   1        }
 548              
C51 COMPILER V9.59.0.0   BSP_ADCOLLECT                                                     04/08/2024 14:55:08 PAGE 10  

 549          
 550          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2099    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     69    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
