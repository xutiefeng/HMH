C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SC95F_UART0
OBJECT MODULE PLACED IN ..\Output\sc95f_uart0.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\FWLib\SC95F_Lib\src\sc95f_uart0.c LARGE OMF2 OPTIMIZE(0,SIZE) BROWSE 
                    -INTVECTOR(0X1000) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..
                    -\Apps;..\Apps) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\sc95f_uart0.lst) TABS(2) OBJECT(..\Output\sc95f_uart0.obj)

line level    source

   1          //************************************************************
   2          //  Copyright (c) 深圳市赛元微电子股份有限公司
   3          //  文件名称:     sc95f_uart0.c
   4          //  作者:         赛元应用团队
   5          //  模块功能:     BTM固件库函数C文件
   6          //  最后更正日期: 2024年1月18日
   7          //  版本:       V1.0002
   8          //  说明:
   9          //*************************************************************
  10          
  11          #include "sc95f_uart0.h"
  12          
  13          #if !defined (SC95R751)
  14          /**************************************************
  15          *函数名称:void UART0_DeInit(void)
  16          *函数功能:UART0相关寄存器复位至缺省值
  17          *入口参数:void
  18          *出口参数:void
  19          **************************************************/
  20          void UART0_DeInit(void)
  21          {
  22   1        SCON = 0X00;
  23   1        SBUF = 0X00;
  24   1        PCON &= 0X7F;
  25   1        IE &= 0XEF;
  26   1        IP &= 0XEF;
  27   1      }
  28          
  29          /**************************************************
  30          *函数名称:void UART0_Init(uint32_t Uart0Fsys, uint32_t BaudRate, UART0_Mode_Typedef Mode,
  31                         UART0_Clock_Typedef ClockMode, UART0_RX_Typedef RxMode)
  32          *函数功能:UART0初始化配置函数
  33          *入口参数:
  34          uint32_t:Uart0Fsys:系统时钟频率
  35          uint32_t:BaudRate:波特率
  36          UART0_Mode_Typedef:Mode:UART0工作模式
  37          UART0_Clock_Typedef:ClockMode:波特率时钟源（TIMER1/TIMER2）
  38          UART0_RX_Typedef:RxMode:接收允许选择
  39          *出口参数:void
  40          **************************************************/
  41          void UART0_Init(uint32_t Uart0Fsys, uint32_t BaudRate, UART0_Mode_Typedef Mode,
  42                  UART0_Clock_Typedef ClockMode, UART0_RX_Typedef RxMode)
  43          {
  44   1        SCON = SCON & 0X2F | Mode | RxMode; //设置UART工作模式,设置接收允许位
  45   1      
  46   1        if(Mode == UART0_Mode_8B)     //UART工作模式为模式0:8位半双工同步通信模式
  47   1        {
  48   2        //模式0时钟来源于系统时钟或系统时钟12分频
  49   2        if(BaudRate == UART0_BaudRate_FsysDIV12)
  50   2        {
  51   3          SCON &= 0XDF;
  52   3        }
  53   2        else if(BaudRate == UART0_BaudRate_FsysDIV4)
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 2   

  54   2        {
  55   3          SCON |= 0X20;
  56   3        }
  57   2        }
  58   1        else//UART工作模式为模式1或者模式3
  59   1        {
  60   2        TXCON = (TXCON & 0xCF) | ClockMode; //设置波特率时钟源
  61   2      
  62   2        /* 使用定时器1作为波特率发生器 */
  63   2        if(ClockMode == UART0_CLOCK_TIMER1)
  64   2        {
  65   3          TH1 = (Uart0Fsys / BaudRate) / 256;
  66   3          TL1 = (Uart0Fsys / BaudRate) % 256;
  67   3          TR1 = 0;
  68   3        }
  69   2        /* 使用定时器2作为波特率发生器 */
  70   2        else if(ClockMode == UART0_CLOCK_TIMER2)
  71   2        {
  72   3          TXINX = 0X02;     //TIMx寄存器组指向定时器2
  73   3          RCAPXH = (Uart0Fsys / BaudRate) / 256;
  74   3          RCAPXL = (Uart0Fsys / BaudRate) % 256;
  75   3          TRX = 1;
  76   3        }
  77   2        }
  78   1          EUART = 1;     //开启Uart中断
  79   1      }
  80          
  81          /*****************************************************
  82          *函数名称:void UART0_SendData8(uint8_t Data)
  83          *函数功能:UART0发送8位数据
  84          *入口参数:
  85          uint8_t:Data:发送的数据
  86          *出口参数:void
  87          *****************************************************/
  88          void UART0_SendData8(uint8_t Data)
  89          {
  90   1        SBUF = Data;
  91   1      }
  92          
  93          /**************************************************
  94          *函数名称:uint8_t UART0_ReceiveData8(void)
  95          *函数功能:获得SBUF中的值
  96          *入口参数:void
  97          *出口参数:
  98          uint8_t:接收的数据
  99          **************************************************/
 100          uint8_t UART0_ReceiveData8(void)
 101          {
 102   1        return SBUF;
 103   1      }
 104          
 105          /*****************************************************
 106          *函数名称:void UART0_SendData9(uint16_t Data)
 107          *函数功能:UART0发送9位数据
 108          *入口参数:
 109          uint16_t:Data:发送的数据
 110          *出口参数:void
 111          *****************************************************/
 112          void UART0_SendData9(uint16_t Data)
 113          {
 114   1        uint8_t Data_9Bit;
 115   1        Data_9Bit = (Data >> 8);
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 3   

 116   1      
 117   1        /* 第9位数据放在SCON寄存器的第3位 */
 118   1        if(Data_9Bit)
 119   1        {
 120   2        SCON |= 0X08;
 121   2        }
 122   1        else
 123   1        {
 124   2        SCON &= 0XF7;
 125   2        }
 126   1      
 127   1        SBUF = (uint8_t)Data;
 128   1      }
 129          
 130          /**************************************************
 131          *函数名称:uint16_t UART0_ReceiveData9(void)
 132          *函数功能:获得SBUF中的值及第九位的值
 133          *入口参数:void
 134          *出口参数:
 135          uint16_t:SBUF中的值及第九位的值
 136          **************************************************/
 137          uint16_t UART0_ReceiveData9(void)
 138          {
 139   1        uint16_t Data9;
 140   1        /* 第9位数据放在SCON寄存器的第3位 */
 141   1        Data9 = SBUF + ((uint16_t)(SCON & 0X04) << 6);
 142   1        SCON &= 0XFB;
 143   1        return Data9;
 144   1      }
 145          
 146          /*****************************************************
 147          *函数名称:void UART0_ITConfig(FunctionalState NewState, PriorityStatus Priority)
 148          *函数功能:UART0中断初始化
 149          *入口参数:
 150          FunctionalState:NewState:中断使能/关闭选择
 151          PriorityStatus:Priority:中断优先级选择
 152          *出口参数:void
 153          *****************************************************/
 154          void UART0_ITConfig(FunctionalState NewState, PriorityStatus Priority)
 155          {
 156   1        if(NewState == DISABLE)
 157   1        {
 158   2        EUART = 0;
 159   2        }
 160   1        else
 161   1        {
 162   2        EUART = 1;
 163   2        }
 164   1      
 165   1        //设置中断优先级
 166   1        if(Priority == LOW)
 167   1        {
 168   2        IPUART = 0;
 169   2        }
 170   1        else
 171   1        {
 172   2        IPUART = 1;
 173   2        }
 174   1      }
 175          
 176          /*****************************************************
 177          *函数名称:StatusTypeDef UART0_Transmit8(UART0_HandleInfoDef* UART_HANDLE, uint8_t *pData, uint8_t Size,uin
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 4   

             -t32_t Timeout)
 178          *函数功能:UART在轮询模式下发送大量数据
 179          *入口参数:
 180          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 181          uint8_t *:pData:待发送数据
 182          uint16_t:Size:待发送的数据量
 183          uint32_t:Timeout:超时时间设置
 184          *出口参数:
 185          StatusTypeDef:函数执行状态
 186          *****************************************************/
 187          StatusTypeDef UART0_Transmit(UART0_HandleInfoDef* UART_HANDLE, uint8_t* pData, uint8_t Size, uint32_t Time
             -out)
 188          {
 189   1        uint32_t TimeoutCnt;
 190   1        /* 检查一个发送进程是否正在进行 */
 191   1        if(UART_HANDLE->TxState == UART0_STATE_READY)
 192   1        {
 193   2        /* 待发送数据长度必须大于0，否则返回错误状态 */
 194   2        if(Size == 0U)
 195   2        {
 196   3          return  Status_ERROR;
 197   3        }
 198   2      
 199   2        UART_HANDLE->TxState = UART0_STATE_BUSY;      //发送进程忙碌中
 200   2        TI = 0; //发送前清除发送标志
 201   2        UART_HANDLE->pTxBuffPtr.Size_u8 = pData;      //指向待发送数据的地址
 202   2        UART_HANDLE->TxXferSize = Size;     //更新待发送的数据量
 203   2        UART_HANDLE->TxXferCount = 0;     //发送计数器清零
 204   2      
 205   2          while(UART_HANDLE->TxXferCount < UART_HANDLE->TxXferSize)//判断是否接收所有数据
 206   2          {
 207   3            if((((SCON & 0xC0))) == UART0_Mode_11B)
 208   3            {
 209   4              SCON &= ~0x08;
 210   4              SCON |= (*(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount) >> 5);//设置第9位校验位
 211   4              SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount);
 212   4            }
 213   3            else
 214   3            {
 215   4              SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u8 + UART_HANDLE->TxXferCount);
 216   4            }
 217   3            
 218   3            while(!TI) //等待发送完成
 219   3            {
 220   4              if(TimeoutCnt++ > Timeout)
 221   4              {
 222   5                UART_HANDLE->TxState = UART0_STATE_TIMEOUT;//发送超时
 223   5                return Status_TIMEOUT;
 224   5              }
 225   4              WDTCON |= 0x10;     //喂狗，防止等待时间过长，导致WDT复位
 226   4            }
 227   3            
 228   3            UART0_ClearFlag(UART0_FLAG_TI); //发送中断标志清除，写1/写0清零
 229   3            TimeoutCnt = 0;
 230   3          UART_HANDLE->TxXferCount ++;  //发送数据量计数
 231   3        }
 232   2      
 233   2        if(UART_HANDLE->TxXferCount == UART_HANDLE->TxXferSize)
 234   2        {
 235   3          UART_HANDLE->TxState = UART0_STATE_READY; //发送完成
 236   3          return Status_OK;
 237   3        }
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 5   

 238   2        else
 239   2        {
 240   3          UART_HANDLE->TxState = UART0_STATE_ERROR;//发生发送错误
 241   3          return Status_ERROR;
 242   3        }
 243   2        }
 244   1        else
 245   1        {
 246   2        return Status_BUSY;//返回忙碌状态
 247   2        }
 248   1      }
 249          
 250          /*****************************************************
 251          *函数名称:StatusTypeDef UART0_Transmit8_IT(UART0_HandleInfoDef *UART_HANDLE, uint8_t *pData, uint8_t Size)
 252          *函数功能:UART在中断模式下发送大量数据时，先在main函数中调用此函数
 253          *入口参数:
 254          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 255          uint8_t *:pData:待发送数据的首地址
 256          uint16_t:Size:待发送的数据量
 257          *出口参数:
 258          StatusTypeDef:函数执行状态
 259          *****************************************************/
 260          StatusTypeDef UART0_Transmit_IT(UART0_HandleInfoDef* UART_HANDLE, uint8_t* pData, uint8_t Size)
 261          {
 262   1        /* 检查一个发送进程是否正在进行 */
 263   1        if (UART_HANDLE->TxState == UART0_STATE_READY)
 264   1        {
 265   2          /* 没有开启UART0中断或发送数据量大小为0，返回错误 */
 266   2          if ((EUART == 0) || (Size == 0U))
 267   2          {
 268   3            return Status_ERROR;
 269   3          }
 270   2      
 271   2        UART_HANDLE->TxState = UART0_STATE_BUSY;      //发送进程忙碌中
 272   2        TI = 0; //发送前清除发送标志
 273   2        UART_HANDLE->pTxBuffPtr.Size_u8 = pData;      //指向待发送数据的地址
 274   2        UART_HANDLE->TxXferSize = Size;     //更新待发送的数据量
 275   2        UART_HANDLE->TxXferCount = 0;     //发送计数器清零
 276   2      
 277   2      
 278   2        /* 发送第1帧数据 */
 279   2        if((SCON & 0xC0) == UART0_Mode_11B)
 280   2        {
 281   3          SCON |= (*(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount) >> 5) & 0x08;//设置第9位校验位
 282   3          SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount);
 283   3        }
 284   2        else
 285   2        {
 286   3          SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u8 + UART_HANDLE->TxXferCount);
 287   3        }
 288   2        return Status_OK;
 289   2        }
 290   1        else
 291   1        {
 292   2        return Status_BUSY;//返回标志位
 293   2        }
 294   1      }
 295          
 296          /*****************************************************
 297          *函数名称:StatusTypeDef UART0_Transmit_IRQHandler(UART0_HandleInfoDef *UART_HANDLE)
 298          *函数功能:UART在中断模式下发送大量数据时，在中断服务函数中调用
 299          * 注：该函数调用前需要判断中断标志位是否置起
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 6   

 300          *入口参数:
 301          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 302          *出口参数:
 303          StatusTypeDef:函数执行状态
 304          *****************************************************/
 305          StatusTypeDef UART0_Transmit_IRQHandler(UART0_HandleInfoDef* UART_HANDLE)
 306          {
 307   1        /* 处于发送线程 */
 308   1        if (UART_HANDLE->TxState == UART0_STATE_BUSY)
 309   1        {
 310   2          UART_HANDLE->TxXferCount++;
 311   2          /* 判断上一次发送是否是最后一次 */
 312   2          if (UART_HANDLE->TxXferCount < UART_HANDLE->TxXferSize)
 313   2          {
 314   3            /* 待发送数据量未为0，继续发送 */
 315   3            if((SCON & 0xC0) == UART0_Mode_11B)
 316   3            {
 317   4              SCON |= (*(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount) >> 5) & 0x08;//设置第9位校验位
 318   4              SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u16 + UART_HANDLE->TxXferCount);
 319   4            }
 320   3            else
 321   3            {
 322   4              SBUF = *(UART_HANDLE->pTxBuffPtr.Size_u8 + UART_HANDLE->TxXferCount);
 323   4            }
 324   3            return Status_BUSY;
 325   3          }
 326   2          else if (UART_HANDLE->TxXferCount == UART_HANDLE->TxXferSize)
 327   2          {
 328   3            /* 发送完成 */
 329   3            UART_HANDLE->TxState = UART0_STATE_READY;
 330   3            return Status_OK;
 331   3          }
 332   2          else
 333   2          {
 334   3            /* 发送数据量为0时还发送数据，返回错误 */
 335   3            UART_HANDLE->TxState = UART0_STATE_ERROR;
 336   3            return Status_ERROR;
 337   3          }
 338   2        }
 339   1        else
 340   1        {
 341   2          return Status_ERROR;
 342   2        }
 343   1      }
 344          
 345          /*****************************************************
 346          *函数名称:UART0_StatusTypeDef UART0_Receive8(UART0_HandleInfoDef* UART_HANDLE, uint8_t *pData, uint8_t Siz
             -e, uint32_t Timeout)
 347          *函数功能:UART在轮询模式下接收大量数据
 348          *入口参数:
 349          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 350          uint8_t *:pData:接收数据的存放
 351          uint16_t:Size:待接收的数据量
 352          uint32_t:Timeout:超时时间设置
 353          *出口参数:
 354          StatusTypeDef:函数执行状态
 355          *****************************************************/
 356          StatusTypeDef UART0_Receive(UART0_HandleInfoDef* UART_HANDLE, uint8_t* pData, uint8_t Size, uint32_t Timeo
             -ut)
 357          {
 358   1        uint32_t TimeoutCnt = 0;
 359   1        /* 检查接收进程正在运行 */
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 7   

 360   1        if(UART_HANDLE->RxState == UART0_STATE_READY)
 361   1        {
 362   2          /* 检查接收数据量大小和是否开启接收使能 */
 363   2          if((Size == 0U) || ((SCON & 0x10) != UART0_RX_ENABLE))
 364   2          {
 365   3            return  Status_ERROR;
 366   3          }
 367   2      
 368   2        UART_HANDLE->RxState = UART0_STATE_BUSY;      //状态更新为接收忙碌中
 369   2        RI = 0;      //接收前清除接收中断标志
 370   2        UART_HANDLE->pRxBuffPtr.Size_u8 = pData;      //指向待发送数据的地址
 371   2        UART_HANDLE->RxXferSize = Size;     //更新待发送的数据量
 372   2        UART_HANDLE->RxXferCount = 0;     //发送计数器清零
 373   2      
 374   2          while(UART_HANDLE->RxXferCount < UART_HANDLE->RxXferSize) //判断是否接收所有数据
 375   2          {
 376   3            if(RI) //判断接收标志位
 377   3            {
 378   4              if((SCON & 0xC0) == UART0_Mode_11B)
 379   4              {
 380   5                *(UART_HANDLE->pRxBuffPtr.Size_u16 + UART_HANDLE->RxXferCount) = SBUF + ((uint16_t)(SCON & 0X04)
             - << 6); //接收数据
 381   5              }
 382   4              else
 383   4              {
 384   5                *(UART_HANDLE->pRxBuffPtr.Size_u8 + UART_HANDLE->RxXferCount) = SBUF;     //接收数据
 385   5              }
 386   4              RI = 0;     //接收标志位清零
 387   4          UART_HANDLE->RxXferCount++; //接收数据量计数加1
 388   4          TimeoutCnt = 0;//收到数据，超时计数清零
 389   4          }
 390   3          else
 391   3          {
 392   4          if(TimeoutCnt++ > Timeout)//计时溢出
 393   4          {
 394   5            UART_HANDLE->RxState = UART0_STATE_TIMEOUT;//发送超时
 395   5            return Status_TIMEOUT;
 396   5          }
 397   4              WDTCON |= 0x10;     //喂狗，防止等待时间过长，导致WDT复位
 398   4          }
 399   3        }
 400   2      
 401   2        if(UART_HANDLE->RxXferCount == UART_HANDLE->RxXferSize)
 402   2        {
 403   3          UART_HANDLE->RxState = UART0_STATE_READY; //接收完成
 404   3          return Status_OK;
 405   3        }
 406   2        else
 407   2        {
 408   3          UART_HANDLE->RxState = UART0_STATE_ERROR;//接收错误
 409   3          return Status_ERROR;
 410   3        }
 411   2        }
 412   1        else
 413   1        {
 414   2        return Status_BUSY;//返回标志位
 415   2        }
 416   1      }
 417          
 418          /*****************************************************
 419          *函数名称:StatusTypeDef UART0_Transmit_IT(UART0_HandleInfoDef *UART_HANDLE, uint8_t *pData, uint8_t Size)
 420          *函数功能:UART在中断模式下接收大量数据时，先在main函数中调用此函数
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 8   

 421          *入口参数:
 422          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 423          uint8_t *:pData:接收数据的存放区
 424          uint16_t:Size:待接收的数据量
 425          *出口参数:
 426          StatusTypeDef:函数执行状态
 427          *****************************************************/
 428          StatusTypeDef UART0_Receive_IT(UART0_HandleInfoDef* UART_HANDLE, uint8_t* pData, uint8_t Size)
 429          {
 430   1        /* 检查一个接收进程是否正在进行 */
 431   1        if (UART_HANDLE->RxState == UART0_STATE_READY)
 432   1        {
 433   2          /* 检查是否开启UART0中断或发送数据量大小为0或是否开启接收使能，返回错误 */
 434   2          if ((EUART == 0) || (Size == 0U) || ((SCON & 0x10) != UART0_RX_ENABLE))
 435   2          {
 436   3            return UART0_STATE_ERROR;
 437   3          }
 438   2      
 439   2        UART_HANDLE->RxState = UART0_STATE_BUSY;
 440   2        UART_HANDLE->pRxBuffPtr.Size_u8 = pData;      //指向接收数据的存放地址
 441   2        UART_HANDLE->RxXferSize = Size;     //更新待接收的数据量
 442   2        UART_HANDLE->RxXferCount = 0;     //发送计数器清零
 443   2      
 444   2        return Status_OK;
 445   2        }
 446   1        else
 447   1        {
 448   2        return Status_BUSY;//返回标志位
 449   2        }
 450   1      }
 451          
 452          /*****************************************************
 453          *函数名称:StatusTypeDef UART0_Receive8_IRQHandler(UART0_HandleInfoDef* UART_HANDLE)
 454          *函数功能:UART在中断模式下接收大量数据时，在中断服务函数中调用
 455          *入口参数:
 456          UART0_HandleInfoDef*:UART_HANDLE:指向包含指定UART模块的配置信息结构体的指针
 457          *出口参数:
 458          StatusTypeDef:函数执行状态
 459          *****************************************************/
 460          StatusTypeDef UART0_Receive_IRQHandler(UART0_HandleInfoDef* UART_HANDLE)
 461          {
 462   1        /* 检查一个接收进程是否正在进行 */
 463   1        if (UART_HANDLE->RxState == UART0_STATE_BUSY)
 464   1        {
 465   2          /* 处于接收线程，检查待接收数据量是否为0 */
 466   2          if (UART_HANDLE->RxXferCount < UART_HANDLE->RxXferSize)
 467   2          {
 468   3            if((SCON & 0xC0) == UART0_Mode_11B)
 469   3            {
 470   4              *(UART_HANDLE->pRxBuffPtr.Size_u16 + UART_HANDLE->RxXferCount) = SBUF + ((uint16_t)(SCON & 0X04) << 6)
             -; //接收数据
 471   4            }
 472   3            else
 473   3            {
 474   4              *(UART_HANDLE->pRxBuffPtr.Size_u8 + UART_HANDLE->RxXferCount) = SBUF;     //接收数据
 475   4            }
 476   3            UART_HANDLE->RxXferCount++;
 477   3            /* 判断上一次发送是否是最后一次 */
 478   3            if (UART_HANDLE->RxXferCount == UART_HANDLE->RxXferSize)
 479   3            {
 480   4              /* 接收完成 */
 481   4              UART_HANDLE->RxState = UART0_STATE_READY;
C51 COMPILER V9.59.0.0   SC95F_UART0                                                       04/02/2024 21:10:02 PAGE 9   

 482   4              return Status_OK;
 483   4            }
 484   3            return Status_BUSY;
 485   3            
 486   3          }
 487   2          else
 488   2          {
 489   3            /* 接收数据量为0时还接收数据，返回错误 */
 490   3            UART_HANDLE->RxState = UART0_STATE_ERROR;
 491   3            return Status_ERROR;
 492   3          }
 493   2        }
 494   1        else
 495   1        {
 496   2          return Status_BUSY;
 497   2        }
 498   1      }
 499          
 500          #endif
 501          
 502          /******************* (C) COPYRIGHT 2020 SinOne Microelectronics *****END OF FILE****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2574    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     69    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
