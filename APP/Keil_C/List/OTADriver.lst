C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE OTADRIVER
OBJECT MODULE PLACED IN ..\Output\OTADriver.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Drivers\OTADriver\C\OTADriver.c LARGE OMF2 OPTIMIZE(8,SIZE) BROWSE IN
                    -TVECTOR(0X2800) INCDIR(..\FWLib\SC95F_Lib\inc;..\User;..\IOT_DRIVER\XIAOMI;..\Drivers;..\Drivers\TKDriver\C;..\List\..\A
                    -pps;..\Apps) DEFINE(SC95F8x1xB) DEBUG PRINT(..\List\OTADriver.lst) TABS(2) OBJECT(..\Output\OTADriver.obj)

line level    source

   1          //************************************************************
   2          //  Copyright (c) ÉîÛÚÊÐÈüÔªÎ¢µç×Ó¹É·ÝÓÐÏÞ¹«Ë¾
   3          //  ÎÄ¼þÃû³Æ:   OTADriver.c
   4          //  ×÷Õß:       ÈüÔªOTAÓ¦ÓÃÍÅ¶Ó
   5          //  Ä£¿é¹¦ÄÜ:   OTA¿âº¯ÊýCÎÄ¼þ
   6          //  ×îºó¸üÕýÈÕÆÚ:2023Äê5ÔÂ10ÈÕ
   7          //  °æ±¾:       V1.0.0
   8          //  ËµÃ÷:       ÓÃÓÚÊµÏÖOTAµÄbootlaod¹¦ÄÜ
   9          //*************************************************************
  10          
  11          #include"..\H\OTADriver.h"
  12          #include"SC_Init.h"
  13          #include "..\H\Decrypt_TEA.H"
  14          #include "..\H\OTADriver_Statement.H"
  15          #include"..\H\OTADriver_IAP.h"
  16          
  17          /*<DriverVarStart>*/
  18          
  19          typedef enum
  20          {
  21            NORMAL,     //APPÕý³£
  22            DOWNLOADED, //ÏÂÔØÍê³É
  23            COPYING,    //¿½±´
  24              OTAING,     //OTAÏÂÔØÖÐ
  25          } APPSPACE_STATE;
  26          
  27          #if(Encryption == 1)//Èç¹ûÊý¾Ý¼ÓÃÜÁËÔÚ´Ë½øÐÐ½âÃÜ
              unsigned int code Key_TEA[4] = 
              {
                (EncryptionKeyH>>16)&0xffff,
                (EncryptionKeyH)&0xffff,
                (EncryptionKeyL>>16)&0xffff,
                (EncryptionKeyL)&0xffff,
              };
              #endif
  36          
  37          
  38          /* Ê¹ÓÃ´®¿Ú¶¨Òå */
  39          #if (UartSelect==0)
  40          #define SendData(UartData) UART0_SendData8((uint8_t)UartData)
  41          #define ReceiveData() UART0_ReceiveData8()
  42          #define READ_RI UART0_GetFlagStatus(UART0_FLAG_RI)
  43          #define CLEAR_RI UART0_ClearFlag(UART0_FLAG_RI)
  44          #define READ_TI UART0_GetFlagStatus(UART0_FLAG_TI)
  45          #define CLEAR_TI UART0_ClearFlag(UART0_FLAG_TI)
  46          #define UART_INT_NUMBER 4
  47          #endif
  48          
  49          #if (UartSelect==1)
              #define SendData(UartData) USCI0_UART_SendData8(UartData)
              #define ReceiveData() USCI0_UART_ReceiveData8()
              #define READ_RI USCI0_GetFlagStatus(USCI0_UART_FLAG_RI)
              #define CLEAR_RI USCI0_ClearFlag(USCI0_UART_FLAG_RI)
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 2   

              #define READ_TI USCI0_GetFlagStatus(USCI0_UART_FLAG_TI)
              #define CLEAR_TI USCI0_ClearFlag(USCI0_UART_FLAG_TI)
              #define UART_INT_NUMBER 14
              #endif
  58          
  59          #if (UartSelect==2)
              #define SendData(UartData) USCI1_UART_SendData8(UartData)
              #define ReceiveData() USCI1_UART_ReceiveData8()
              #define READ_RI USCI1_GetFlagStatus(USCI1_UART_FLAG_RI)
              #define CLEAR_RI USCI1_ClearFlag(USCI1_UART_FLAG_RI)
              #define READ_TI USCI1_GetFlagStatus(USCI1_UART_FLAG_TI)
              #define CLEAR_TI USCI1_ClearFlag(USCI1_UART_FLAG_TI)
              #define UART_INT_NUMBER 15
              #endif
  68          
  69          #if (UartSelect==3)
              #define SendData(UartData) USCI2_UART_SendData8(UartData)
              #define ReceiveData() USCI2_UART_ReceiveData8()
              #define READ_RI USCI2_GetFlagStatus(USCI2_UART_FLAG_RI)
              #define CLEAR_RI USCI2_ClearFlag(USCI2_UART_FLAG_RI)
              #define READ_TI USCI2_GetFlagStatus(USCI2_UART_FLAG_TI)
              #define CLEAR_TI USCI2_ClearFlag(USCI2_UART_FLAG_TI)
              #define UART_INT_NUMBER 16
              #endif
  78          
  79          #if (UartSelect==4)
              #define SendData(UartData) USCI3_UART_SendData8(UartData)
              #define ReceiveData() USCI3_UART_ReceiveData8()
              #define READ_RI USCI3_GetFlagStatus(USCI3_UART_FLAG_RI)
              #define CLEAR_RI USCI3_ClearFlag(USCI3_UART_FLAG_RI)
              #define READ_TI USCI3_GetFlagStatus(USCI3_UART_FLAG_TI)
              #define CLEAR_TI USCI3_ClearFlag(USCI3_UART_FLAG_TI)
              #define UART_INT_NUMBER 17
              #endif
  88          
  89          #if (UartSelect==5)
              #define SendData(UartData) USCI4_UART_SendData8(UartData)
              #define ReceiveData() USCI4_UART_ReceiveData8()
              #define READ_RI USCI4_GetFlagStatus(USCI4_UART_FLAG_RI)
              #define CLEAR_RI USCI4_ClearFlag(USCI4_UART_FLAG_RI)
              #define READ_TI USCI4_GetFlagStatus(USCI4_UART_FLAG_TI)
              #define CLEAR_TI USCI4_ClearFlag(USCI4_UART_FLAG_TI)
              #define UART_INT_NUMBER 18
              #endif
  98          
  99          
 100          
 101          unsigned char data InterruputMode _at_ 0x20;
 102          
 103          void (*UartReceive)(char Data);
 104          unsigned char BOOT_WaitTime=0;
 105          
 106          bit  UartSeneFlag=0;
 107          unsigned char APP_UPDATA_FLAG_ARRAY[] = {APP_UPDATA_FLAG_NUMBER};
 108          
 109          unsigned char Option1Buff;
 110          unsigned char Option2Buff;
 111          APPMemoryInfoStruct RUN_APPMemoryInfoData;
 112          APPMemoryInfoStruct BACKUPS_APPMemoryInfoData;
 113          
 114          IAPDATA_INFO  IAP_Pack;
 115          unsigned long  IAP_Checksum=0;
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 3   

 116          unsigned long IAP_Size=0;
 117          
 118          
 119          
 120          //====================================================
 121          void ReadAPPMemoryInfo();
 122          void ReadBACKSMemoryInfo();
 123          void IAP_Reset(unsigned char mode);
 124          /*****************************************************
 125          *º¯ÊýÃû³Æ: void OTA_Init(void)
 126          *º¯Êý¹¦ÄÜ: OTA³õÊ¼»¯£¬±£´æAPP Option¡¢EAÐÅÏ¢
 127          *Èë¿Ú²ÎÊý£º
 128          *³ö¿Ú²ÎÊý£ºvoid 
 129          *****************************************************/
 130          void OTA_Init(void UartReceiveHandle(char Data),char *UartReceiveBuf)
 131          {
 132   1      #if(PROJECT_SWITCH==1)
 133   1        {
 134   2          char temp=UpdateSucceededFlagNumber[0];  //±ÜÃâUpdateSucceededFlagNumber±»ÓÅ»¯
 135   2          temp +=(char)VersionDate;                //±ÜÃâVersionDate±»ÓÅ»¯
 136   2        }
 137   1      #endif  
 138   1        IAP_Pack.State =OTA_READY;
 139   1          IAP_Pack.PacketNumber=0;
 140   1          IAP_Pack.Size=0;
 141   1          IAP_Pack.Memory=UartReceiveBuf;
 142   1        
 143   1        UartReceive=UartReceiveHandle;
 144   1      }
 145          /**************************************************
 146          *º¯ÊýÃû³Æ£ºOTA_JumpApp
 147          *º¯Êý¹¦ÄÜ£ºÐÞ¸ÄÌø×ª±êÖ¾Î»£¬²¢ÇÒ¿ªÆô
 148          *Èë¿Ú²ÎÊý£ºvoid
 149          *³ö¿Ú²ÎÊý£ºvoid
 150          **************************************************/
 151          void OTA_JumpApp(void)
 152          {
 153   1      #if LDROM_MODE
                IAP_Reset(APP);         //Èí¼þ¸´Î»
              #else
 156   1        (*(void(code *)(void))(RUN_APP_STARTUP_ADDRESS))();  //Ìø×ªµ½APP³ÌÐòÈë¿Ú
 157   1      #endif  
 158   1      }
 159          
 160          /**************************************************
 161          *º¯ÊýÃû³Æ£ºOTA_JumpBoot
 162          *º¯Êý¹¦ÄÜ£ºÌæ»»µ½Bootº¯Êý
 163          *Èë¿Ú²ÎÊý£ºvoid
 164          *³ö¿Ú²ÎÊý£ºvoid
 165          **************************************************/
 166          void OTA_JumpBoot(void)
 167          {
 168   1      #if LDROM_MODE
                IAP_Reset(BOOT);          //Èí¼þ¸´Î»
              #else
 171   1        (*(void(code *)(void))(0x0000))();  //Ìø×ªµ½BOOT³ÌÐòÈë¿Ú
 172   1      #endif  
 173   1      }
 174          
 175          /**************************************************
 176          *º¯ÊýÃû³Æ£ºIAP_Reset
 177          *º¯Êý¹¦ÄÜ£ºÈí¸´Î»
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 4   

 178          *Èë¿Ú²ÎÊý£ºmode £ºBOOT£º¸´Î»Ö´ÐÐLDROM³ÌÐò APP£º¸´Î»Ö´ÐÐAPP³ÌÐò
 179          *³ö¿Ú²ÎÊý£ºvoid  
 180          **************************************************/
 181          void IAP_Reset(unsigned char mode)
 182          {
 183   1          
 184   1        IAPKEY = 0XF0;  //Ê¹ÄÜIAP
 185   1        if(mode==BOOT)
 186   1        {
 187   2          IAPADE = 0X03;   //MOVC Õë¶ÔLDROM
 188   2          IAPCTL |= 0x80; //BTLD¿ØÖÆÎ»ÖÃÆð£¬ÏÂ´Î¸´Î»½øÈëLDROM
 189   2        }
 190   1        else
 191   1        { 
 192   2          IAPADE = 0X00;   //MOVC Õë¶ÔAPROM
 193   2          IAPCTL &= ~0x80;//BTLD¿ØÖÆÎ»Çå0£¬ÏÂ´Î¸´Î»ºó½øÈëAPROM
 194   2        }
 195   1        PCON |= 0X08; //Èí¼þ¸´Î»
 196   1        _nop_();    //µÈ´ý8¸ö_nop_()
 197   1        _nop_();
 198   1        _nop_();
 199   1        _nop_();
 200   1        _nop_();
 201   1        _nop_();
 202   1        _nop_();
 203   1        _nop_();
 204   1        _nop_();
 205   1      }
 206          /*****************************************************
 207          *º¯ÊýÃû³Æ: void  SetInterruptApp()
 208          *º¯Êý¹¦ÄÜ: ÉèÖÃÖÐ¶ÏÎªAPPÖÐ¶Ï¹¦ÄÜ
 209          *Èë¿Ú²ÎÊý£º
 210          *³ö¿Ú²ÎÊý£º
 211          *****************************************************/
 212          void  SetInterruptAPP()
 213          {
 214   1        InterruputMode=0xFF;
 215   1      }
 216          /*****************************************************
 217          *º¯ÊýÃû³Æ: SetInterruptBoot()
 218          *º¯Êý¹¦ÄÜ: ÉèÖÃÖÐ¶ÏÎªBOOTLOADERÖÐ¶Ï¹¦ÄÜ
 219          *Èë¿Ú²ÎÊý£º
 220          *³ö¿Ú²ÎÊý£º
 221          *****************************************************/
 222          void  SetInterruptBOOT()
 223          {
 224   1        InterruputMode=0x00;
 225   1      }
 226          /*****************************************************
 227          *º¯ÊýÃû³Æ:void UART_SendData8(uint8_t Data)
 228          *º¯Êý¹¦ÄÜ:UART·¢ËÍ8Î»Êý¾Ý
 229          *Èë¿Ú²ÎÊý:uint8_t:Data:·¢ËÍµÄÊý¾Ý
 230          *³ö¿Ú²ÎÊý:void
 231          *****************************************************/
 232          void UART_SendByte(uint8_t UartData)
 233          {
 234   1        unsigned int i=0;
 235   1        UartSeneFlag=0;
 236   1        SendData(UartData);
 237   1        while(!UartSeneFlag)
 238   1        {
 239   2          if(2000<i++)
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 5   

 240   2          {
 241   3            WDTCON |=0X10;
 242   3            break;
 243   3          }
 244   2        }
 245   1      }
 246          /*****************************************************
 247          *º¯ÊýÃû³Æ:void UART_SendString(char *str)
 248          *º¯Êý¹¦ÄÜ:UART·¢ËÍ×Ö·û´®
 249          *Èë¿Ú²ÎÊý:char *str:·¢ËÍµÄÊý¾Ý
 250          *³ö¿Ú²ÎÊý:void
 251          *****************************************************/
 252          void UART_SendString(char *str)
 253          {
 254   1          while (*str != '\0')
 255   1          {
 256   2          UART_SendByte(*str++);      
 257   2          }
 258   1      }
 259          /**************************************************
 260          *º¯ÊýÃû³Æ£ºUart_Handle
 261          *º¯Êý¹¦ÄÜ£ºuartÖÐ¶Ï´¦Àí
 262          *Èë¿Ú²ÎÊý£º
 263          *³ö¿Ú²ÎÊý£ºvoid  
 264          **************************************************/
 265          void Uart_Handle(void)
 266          {
 267   1        char Data;
 268   1        if(READ_TI)
 269   1        {
 270   2          CLEAR_TI;
 271   2          UartSeneFlag=1;
 272   2        }
 273   1        if(READ_RI)
 274   1        {
 275   2          CLEAR_RI;
 276   2          Data=ReceiveData();
 277   2          UartReceive(Data);
 278   2        }
 279   1      
 280   1      }
 281          /*****************************************************
 282          *º¯ÊýÃû³Æ: unsigned char SaveOTA_to_BacksArea(IAPDATA_INFO IAP_Pack)
 283          *º¯Êý¹¦ÄÜ: ½«OTAÊý¾ÝÐ´Èë±¸·ÝÇø£¬²¢·µ»Ø³É¹¦Ð´Èë×Ö½ÚÊý
 284          *Èë¿Ú²ÎÊý£ºOTAÊý¾Ý°ü
 285          *³ö¿Ú²ÎÊý£ºÐ´Èëµ½±¸·ÝÇø×Ö½ÚÊý 
 286          *****************************************************/
 287          unsigned int SaveOTA_to_BacksArea(IAPDATA_INFO *IAP_Pack)
 288          {
 289   1        uint16_t  IapLen=0;
 290   1          if(IAP_Pack->PacketNumber==0)   //Ê×°üÊý¾Ý£¬²Á³ý±¸·ÝÇø
 291   1          {
 292   2            EraseSpace(BACKUPS_APP_BEGIN_ADDRESS,BACKUPS_APP_END_ADDRESS);  //²Á³ý±¸·ÝÇøÓò
 293   2            IAP_Size=0;
 294   2            IAP_Checksum=0;     
 295   2          }
 296   1          IapLen=IAP_Pack->Size;
 297   1      
 298   1          if((((IAP_Pack->PacketNumber)*(IAP_Pack->Size))>=RUN_APP_BEGIN_ADDRESS)&&(((IAP_Pack->PacketNumber)*(IAP
             -_Pack->Size))<RUN_APP_END_ADDRESS))  //½öÐ´ÈëÓÐÐ§ÇøÓò
 299   1          {
 300   2            {
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 6   

 301   3            #if(Encryption == 1)//Èç¹ûÊý¾Ý¼ÓÃÜÁËÔÚ´Ë½øÐÐ½âÃÜ
                      unsigned char i,k;
                      for(k=0;k<IapLen/4;k++)
                      {
                        for(i=0;i<4;i++) //½«´ý½âÃÜµÄÖµ´æÈëTeaChunckÖÐ
                        {
                          TeaChunck.Chunk8bit[i] = IAP_Pack->Memory[i+k*4]; 
                        }
                        decrypt();  //½âÃÜ
                        for(i=0;i<4;i++) //´ÓTeaChunckÖÐÈ¡µÃ½âÃÜµÄ½á¹û
                        {
                          IAP_Pack->Memory[i+k*4] = TeaChunck.Chunk8bit[i];
                        }
                      }
                    #endif      
 316   3            }       
 317   2            if(((IAP_Pack->PacketNumber)*(IAP_Pack->Size))==(RUN_APP_END_ADDRESS-(IAP_Pack->Size)))
 318   2            {
 319   3              IapLen -=0x10;         //ÔËÐÐÐÅÏ¢Çø²»ÄÜÐ´Èë
 320   3            }   
 321   2            if(WriteBackupsAppData(((IAP_Pack->PacketNumber)*(IAP_Pack->Size)-RUN_APP_BEGIN_ADDRESS),IAP_Pack->Memo
             -ry,IapLen))//Ð´Èë±¸·ÝÇø
 322   2            {
 323   3              IAP_Checksum=CheckSum32(IAP_Checksum,IAP_Pack->Memory,IapLen); //¼ÆËã¹Ì¼þ°üµÄCheck
 324   3              IAP_Size +=IapLen;
 325   3            }
 326   2            else
 327   2            {
 328   3              IapLen=0;
 329   3            }
 330   2          }
 331   1        return IapLen;
 332   1      }
 333          /*****************************************************
 334          *º¯ÊýÃû³Æ: void BootInit(void)
 335          *º¯Êý¹¦ÄÜ: BootLoad³õÊ¼»¯£¬±£´æAPP Option¡¢EAÐÅÏ¢
 336          *Èë¿Ú²ÎÊý£º
 337          *³ö¿Ú²ÎÊý£ºvoid 
 338          *****************************************************/
 339          void BootLoadInit()
 340          {
 341   1        OPINX = 0xC2;
 342   1        Option2Buff = OPREG;       //½«C2µÄ¼Ä´æÆ÷Öµ±£´æ
 343   1        OPREG |= 0X0C;
 344   1        
 345   1        OPINX = 0xC1;
 346   1        Option1Buff = OPREG;     //½«C1µÄ¼Ä´æÆ÷Öµ±£´æ
 347   1        
 348   1        //¶¨Ê±500MS BTM
 349   1          BTMCON = 0X85;  
 350   1      }
 351          /*****************************************************
 352          *º¯ÊýÃû³Æ: void BootLoad_DeInit(void)
 353          *º¯Êý¹¦ÄÜ: »Ö¸´APP Option¡¢EAÐÅÏ¢
 354          *Èë¿Ú²ÎÊý£º
 355          *³ö¿Ú²ÎÊý£ºvoid 
 356          *****************************************************/
 357          void BootLoad_DeInit()
 358          {
 359   1        OPINX = 0xC2;
 360   1        OPREG=Option2Buff;       //»Ö¸´C2µÄ¼Ä´æÆ÷
 361   1        
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 7   

 362   1        OPINX = 0xC1;
 363   1        OPREG=Option1Buff ;    //»Ö¸´C1µÄ¼Ä´æÆ÷
 364   1      }
 365          
 366          
 367          /*****************************************************
 368          *º¯ÊýÃû³Æ: void EraseSpace(unsigned long BeginAddr,unsigned long EndAddr)
 369          *º¯Êý¹¦ÄÜ: Çå³ý¿Õ¼ä
 370          *Èë¿Ú²ÎÊý£ºBeginAddr Çå³ýÆðÊ¼µØÖ·£¬EndAddr Çå³ý½áÊøµØÖ·
 371          *³ö¿Ú²ÎÊý£ºvoid 
 372          *****************************************************/
 373          void EraseSpace(unsigned long BeginAddr,unsigned long EndAddr)
 374          {
 375   1        for(; BeginAddr < EndAddr; BeginAddr += 512)
 376   1        {
 377   2           WDTCON |=0X10;
 378   2           IAP_Erase_512B(BeginAddr);
 379   2        }
 380   1      }
 381          
 382          /*****************************************************
 383          *º¯ÊýÃû³Æ: APPMemoryInfoStruct ReadAPPMemoryInfo()
 384          *º¯Êý¹¦ÄÜ: ¶ÁÈ¡ÔËÐÐÇøÐÅÏ¢
 385          *Èë¿Ú²ÎÊý£º
 386          *³ö¿Ú²ÎÊý£º
 387          *****************************************************/
 388          void ReadAPPMemoryInfo()
 389          {
 390   1        IAP_ReadNByte(RUN_APP_MEMORY_INFO_ADRESS, sizeof(APPMemoryInfoStruct), &RUN_APPMemoryInfoData);
 391   1      }
 392          /*****************************************************
 393          *º¯ÊýÃû³Æ: APPMemoryInfoStruct ReadAPPMemoryInfo()
 394          *º¯Êý¹¦ÄÜ: ¶ÁÈ¡±¸·ÝÇøÐÅÏ¢
 395          *Èë¿Ú²ÎÊý£º
 396          *³ö¿Ú²ÎÊý£º
 397          *****************************************************/
 398          void ReadBACKSMemoryInfo()
 399          {
 400   1        IAP_ReadNByte(BACKUPS_APP_MEMORY_INFO_ADRESS, sizeof(APPMemoryInfoStruct), &BACKUPS_APPMemoryInfoData);
 401   1      }
 402          ///*****************************************************
 403          //*º¯ÊýÃû³Æ: unsigned long ReadAppDate(char region)
 404          //*º¯Êý¹¦ÄÜ: ¶ÁAPP°æ±¾ÈÕÆÚ
 405          //*Èë¿Ú²ÎÊý£º
 406          //*³ö¿Ú²ÎÊý£ºunsigned long£ºÈÕÆÚ
 407          //*****************************************************/
 408          unsigned long ReadAppDate(char region)
 409          {
 410   1        unsigned long Date;
 411   1        if(region)
 412   1        {
 413   2          IAP_ReadNByte(BACKUPS_APP_INFO_ADDRESS, sizeof(unsigned long), &Date);
 414   2        }
 415   1        else
 416   1        {
 417   2          IAP_ReadNByte(RUN_APP_INFO_ADDRESS, sizeof(unsigned long), &Date);
 418   2        }
 419   1        
 420   1        return Date;
 421   1      }
 422          /*****************************************************
 423          *º¯ÊýÃû³Æ: unsigned char WriteAPPMemoryInfo(char region,APPMemoryInfoStruct APPMemoryInfo)
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 8   

 424          *º¯Êý¹¦ÄÜ: Ð´±¸·ÝÇø´æ´¢ÇøÐÅÏ¢
 425          *Èë¿Ú²ÎÊý£ºAPPMemoryInfo:´æ´¢ÇøÐÅÏ¢
 426          *³ö¿Ú²ÎÊý£º
 427          *****************************************************/
 428          unsigned char WriteAPPMemoryInfo(APPMemoryInfoStruct APPMemoryInfo)
 429          {
 430   1          IAP_WriteNByte(BACKUPS_APP_MEMORY_INFO_ADRESS, sizeof(APPMemoryInfoStruct), &APPMemoryInfo);
 431   1        return 1; 
 432   1      }
 433          
 434          /*****************************************************
 435          *º¯ÊýÃû³Æ: unsigned char WriteBackupsAppData(unsigned int OffsetAddress, unsigned char *Data, unsigned int
             - Length)
 436          *º¯Êý¹¦ÄÜ: Ð´APPÊý¾Ý
 437          *Èë¿Ú²ÎÊý£ºOffsetAddress£ºÆ«ÒÆµØÖ·£¬Data £ºÊý¾Ý£¬ Length£ºÊý¾Ý³¤¶È
 438          *³ö¿Ú²ÎÊý£º
 439          *****************************************************/
 440          unsigned char WriteBackupsAppData(unsigned int OffsetAddress, unsigned char *Data, unsigned int Length)
 441          {
 442   1      
 443   1          if(OffsetAddress + Length > APP_SPACE_SIZE - 0x10)
 444   1        return 0;
 445   1        
 446   1        if(IAP_WriteNByte((unsigned long)BACKUPS_APP_BEGIN_ADDRESS + OffsetAddress ,Length, Data) == 0)
 447   1          return 0;
 448   1        
 449   1        return 1;
 450   1      }
 451          
 452          /*****************************************************
 453          *º¯ÊýÃû³Æ: unsigned char AppUpdataFlagCheck(char region)
 454          *º¯Êý¹¦ÄÜ: APP¸üÐÂÍê³É±êÖ¾¼ì²é
 455          *Èë¿Ú²ÎÊý£ºregion 0£º¶ÁÈ¡ÔËÐÐÇøÐÅÏ¢ 1£º¶ÁÈ¡±¸·ÝÇøÐÅÏ¢
 456          *³ö¿Ú²ÎÊý£ºunsigned char 1£º¸üÐÂÍê³É 
 457          *****************************************************/
 458          unsigned char AppUpdataFlagCheck(char region)
 459          {
 460   1        unsigned char i;
 461   1          unsigned long CheckAddr=RUN_APP_MEMORY_INFO_ADRESS;
 462   1        
 463   1        if(region)
 464   1        {
 465   2          CheckAddr=BACKUPS_APP_MEMORY_INFO_ADRESS;
 466   2        }
 467   1        
 468   1         
 469   1          for(i=0;i<sizeof(APP_UPDATA_FLAG_ARRAY);i++)
 470   1          {
 471   2            if(APP_UPDATA_FLAG_ARRAY[i]!=IAP_ReadOneByte(CheckAddr+i))
 472   2              return 0;
 473   2          }
 474   1      
 475   1        return 1;
 476   1      }
 477          
 478          /*****************************************************
 479          *º¯ÊýÃû³Æ: unsigned char AppCompleteCheck(char region)
 480          *º¯Êý¹¦ÄÜ: ¼ì²é´úÂëÍêÕû
 481          *Èë¿Ú²ÎÊý£º
 482          *³ö¿Ú²ÎÊý£ºunsigned char 1£º´úÂëÍêÕû
 483          *****************************************************/
 484          unsigned char AppCompleteCheck()
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 9   

 485          {
 486   1        APPSPACE_STATE RunState=OTAING;
 487   1      
 488   1        unsigned long AppDate,BackData;
 489   1        
 490   1        AppDate=ReadAppDate(0);   //¶ÁÈ¡ÔËÐÐÇø°æ±¾ÈÕÆÚÐÅÏ¢
 491   1        
 492   1        if(((AppDate&0xF0000000)>0x90000000)||
 493   1           ((AppDate&0x0F000000)>0x09000000)||
 494   1           ((AppDate&0x00F00000)>0x00900000)||
 495   1           ((AppDate&0x000F0000)>0x00090000)||
 496   1           ((AppDate&0x0000F000)>0x00009000)||
 497   1           ((AppDate&0x00000F00)>0x00000900)||
 498   1           ((AppDate&0x000000F0)>0x00000090)||
 499   1           ((AppDate&0x0000000F)>0x00000009))
 500   1        {
 501   2          AppDate=0;    //°æ±¾ÈÕÆÚ¸ñÊ½·Ç·¨
 502   2        }
 503   1        
 504   1        BackData=ReadAppDate(1); //¶ÁÈ¡±¸·ÝÇø°æ±¾ÈÕÆÚÐÅÏ¢
 505   1      
 506   1        ReadBACKSMemoryInfo(); //¶ÁÈ¡±¸·ÝÇøÐÅÏ¢
 507   1        ReadAPPMemoryInfo();  //¶ÁÈ¡ÔËÐÐÇøÐÅÏ¢
 508   1      
 509   1        
 510   1        if((BACKUPS_APPMemoryInfoData.UpdateSucceededFlagNumber[0]==APP_UPDATA_FLAG_ARRAY[0])&&
 511   1          (BACKUPS_APPMemoryInfoData.UpdateSucceededFlagNumber[1]==APP_UPDATA_FLAG_ARRAY[1])&&
 512   1          (BACKUPS_APPMemoryInfoData.UpdateSucceededFlagNumber[2]==APP_UPDATA_FLAG_ARRAY[2])&&
 513   1          (BACKUPS_APPMemoryInfoData.UpdateSucceededFlagNumber[3]==APP_UPDATA_FLAG_ARRAY[3]))    //±¸·ÝÇø´úÂëÊÇÍêÕ
             -û
 514   1        {
 515   2          RunState=DOWNLOADED;  //±¸·ÝÇø´úÂëÒÑÏÂÔØÓÐ¹Ì¼þ
 516   2        }
 517   1        else
 518   1        {
 519   2          RunState=OTAING;  //´ýOTAÏÂÔØ
 520   2        }
 521   1        
 522   1        do{
 523   2          if(RunState==DOWNLOADED) //¹Ì¼þÒÑÏÂÔØÍê³É
 524   2          {
 525   3            if(BackData>AppDate)   //ÓÐ¸üÐÂ°æ±¾,¸üÐÂ³ÌÐò
 526   3            {
 527   4              RunState=COPYING;  
 528   4              break;
 529   4            }
 530   3            #if FORCE_UPDATA    //Ç¿ÖÆ¸üÐÂ³ÌÐò
                        RunState=COPYING;
                        break;
                    #endif          
 534   3          }
 535   2          if((RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[0]==APP_UPDATA_FLAG_ARRAY[0])&&
 536   2            (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[1]==APP_UPDATA_FLAG_ARRAY[1])&&
 537   2            (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[2]==APP_UPDATA_FLAG_ARRAY[2])&&
 538   2            (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[3]==APP_UPDATA_FLAG_ARRAY[3]))    //APPÇø´úÂëÊÇÍêÕû
 539   2            {  
 540   3            RunState=NORMAL;
 541   3          }
 542   2          else
 543   2          {
 544   3            if(RunState==DOWNLOADED)        //APPÇø´úÂë²»ÍêÕû£¬ÇÒ±¸·ÝÇø´úÂëÍêÕû
 545   3            {
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 10  

 546   4              RunState=COPYING;//¸üÐÂ³ÌÐò
 547   4            }
 548   3          }
 549   2        }while(0);
 550   1      //  
 551   1        if(RunState==NORMAL)         //²»ÐèÒªÉý¼¶´úÂë,µ½APPÔËÐÐ³ÌÐò
 552   1        {
 553   2          return 1;
 554   2        }
 555   1        if(RunState==COPYING)        //½«±¸·ÝÇø´úÂë¿½±´µ½ÔËÐÐÇø
 556   1        {
 557   2          if(BackupsToRunCopy())   //µÚÒ»´ÎCOPY
 558   2          {
 559   3            return 1;
 560   3          }
 561   2          if(BackupsToRunCopy())   //µÚÒ»´ÎCOPY²»³É¹¦,ÔÙ´ÎCOPY
 562   2          {
 563   3            return 1;
 564   3          }   
 565   2        }
 566   1        return  0;
 567   1      }
 568          /*****************************************************
 569          *º¯ÊýÃû³Æ: unsigned char IAP_Update_Finish(unsigned char Crc)
 570          *º¯Êý¹¦ÄÜ: ¼ì²éOTA½á¹û
 571          *Èë¿Ú²ÎÊý£º
 572          *³ö¿Ú²ÎÊý£º0 £ºÊ§°Ü 1£º³É¹¦
 573          *****************************************************/
 574          unsigned char IAP_BacksArea_CrcCheck()
 575          {
 576   1        APPMemoryInfoStruct APPMemoryInfoTemp;
 577   1        unsigned long crc=0;
 578   1        unsigned long i;
 579   1        unsigned char Data;
 580   1        for(i=0;i<IAP_Size;i++)
 581   1        {
 582   2          WDTCON |=0X10;
 583   2          Data=IAP_ReadOneByte(BACKUPS_APP_BEGIN_ADDRESS+i);
 584   2          crc=CheckSum32(crc, &Data, 1);
 585   2        }
 586   1      
 587   1        if(crc==IAP_Checksum)
 588   1        { 
 589   2          APPMemoryInfoTemp.APPSize = IAP_Size;
 590   2          APPMemoryInfoTemp.APPChecksums=IAP_Checksum;
 591   2          //ÉèÖÃ¸üÐÂÍê³É±êÖ¾
 592   2          APPMemoryInfoTemp.UpdateSucceededFlagNumber[0] = APP_UPDATA_FLAG_ARRAY[0];
 593   2          APPMemoryInfoTemp.UpdateSucceededFlagNumber[1] = APP_UPDATA_FLAG_ARRAY[1];
 594   2          APPMemoryInfoTemp.UpdateSucceededFlagNumber[2] = APP_UPDATA_FLAG_ARRAY[2];
 595   2          APPMemoryInfoTemp.UpdateSucceededFlagNumber[3] = APP_UPDATA_FLAG_ARRAY[3];
 596   2          APPMemoryInfoTemp.InitFlag = INITFLAG; //±êÖ¾²»ÊÇÔ­Ê¼APP
 597   2          //Ð´Èë´æ´¢ÇøÐÅÏ¢
 598   2          WriteAPPMemoryInfo(APPMemoryInfoTemp);      
 599   2          return 1;
 600   2        }
 601   1        
 602   1        return 0;
 603   1      }
 604          /*****************************************************
 605          *º¯ÊýÃû³Æ: unsigned char IAP_Check_APFLASH()
 606          *º¯Êý¹¦ÄÜ: ÅÐ¶ÏÔËÐÐÇøAPPÊÇ·ñÎª×î¿ªÊ¼µÄAPP,Èç¹û²»ÊÇÔò¼ì²é³ÌÐòµÄÍê±¸ÐÔ
 607          *Èë¿Ú²ÎÊý£ºCrc 0£ºÉÏµç²»¶ÔAPPÇø½øÐÐCRCÐ£Ñé£» 1£ºÉÏµç¶ÔAPPÇø½øÐÐCRCÐ£Ñé£¬ÉÏµçÒýµ¼Ê±¼ä±ä³¤
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 11  

 608          *³ö¿Ú²ÎÊý£º0 £º²»ÊÇ 1£ºÊÇ
 609          *****************************************************/
 610          unsigned char IAP_Check_APFLASH(unsigned char Crc)
 611          {
 612   1        unsigned long Iap_crc=0;
 613   1        unsigned long i;
 614   1        unsigned char Data;
 615   1        
 616   1        ReadAPPMemoryInfo();  //¶ÁÈ¡ÔËÐÐÇøÐÅÏ¢
 617   1        
 618   1        if((RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[0]==APP_UPDATA_FLAG_ARRAY[0])&&
 619   1          (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[1]==APP_UPDATA_FLAG_ARRAY[1])&&
 620   1          (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[2]==APP_UPDATA_FLAG_ARRAY[2])&&
 621   1          (RUN_APPMemoryInfoData.UpdateSucceededFlagNumber[3]==APP_UPDATA_FLAG_ARRAY[3]))    //´úÂëÊÇÍêÕû
 622   1        {
 623   2          if(Crc==0)
 624   2          {
 625   3            return 1;                              //²»¼ì²éCRC
 626   3          }
 627   2          if(RUN_APPMemoryInfoData.InitFlag != INITFLAG) //APPÊÇ·ñÎª³ö³§µÄAPP
 628   2          {
 629   3            return 1;                              //³ö³§APP²»¼ì²éCRC
 630   3          }
 631   2          else
 632   2          {
 633   3            for(i=0;i<RUN_APPMemoryInfoData.APPSize;i++)
 634   3            {
 635   4              WDTCON |=0X10;
 636   4              Data=IAP_ReadOneByte(RUN_APP_BEGIN_ADDRESS+i);
 637   4              Iap_crc=CheckSum32(Iap_crc, &Data, 1);
 638   4            }
 639   3            if(Iap_crc==(RUN_APPMemoryInfoData.APPChecksums&0xFFFFFFFF)) //Éý¼¶ºó³ÌÐòµÄCRCÊÇÕýÈ·µÄ
 640   3            {
 641   4              return 1;
 642   4            }
 643   3          }
 644   2        }
 645   1        return  0;
 646   1      }
 647          /*****************************************************
 648          *º¯ÊýÃû³Æ: unsigned char BackupsToRunCopy()
 649          *º¯Êý¹¦ÄÜ: ½«±¸·ÝÇø´úÂë¿½±´µ½ÔËÐÐÇø
 650          *Èë¿Ú²ÎÊý£º
 651          *³ö¿Ú²ÎÊý£º0 £º¿½±´Ê§°Ü 1£º¿½±´³É¹¦
 652          *****************************************************/
 653          unsigned char BackupsToRunCopy()
 654          {
 655   1        unsigned int i = 0;
 656   1        unsigned char BackupsCode = 0;
 657   1      
 658   1         ReadBACKSMemoryInfo();//¶ÁÈ¡±¸·ÝÇøÐÅÏ¢
 659   1      
 660   1        //Çå³ý´úÂëÇø
 661   1        EraseSpace(RUN_APP_BEGIN_ADDRESS,RUN_APP_END_ADDRESS);
 662   1      //  
 663   1        for(i=0;i<BACKUPS_APPMemoryInfoData.APPSize;i++)
 664   1        {
 665   2          WDTCON |=0X10;
 666   2          BackupsCode = IAP_ReadOneByte(BACKUPS_APP_BEGIN_ADDRESS + i);
 667   2          if(!IAP_WriteOneByte(RUN_APP_BEGIN_ADDRESS + i,BackupsCode))
 668   2          {
 669   3            return 0;
C51 COMPILER V9.59.0.0   OTADRIVER                                                         03/23/2024 09:11:12 PAGE 12  

 670   3          }
 671   2        }
 672   1        IAP_WriteNByte(RUN_APP_MEMORY_INFO_ADRESS, sizeof(APPMemoryInfoStruct), &BACKUPS_APPMemoryInfoData);  //¸
             -üÐÂAPPÇøÐÅÏ¢
 673   1        
 674   1            #if FORCE_UPDATA    //Ç¿ÖÆ¸üÐÂ³ÌÐò
                            IAP_Erase_512B(BACKUPS_APP_MEMORY_INFO_ADRESS);
                    #endif        
 677   1        return 1;
 678   1      }
 679          
 680          /******************************************************************************
 681           * Name:    Check-32
 682           * Poly:   
 683           * Init:    
 684           * Refin:   
 685           * Refout:  
 686           * Xorout:  
 687           * Alias:   
 688           *****************************************************************************/
 689          unsigned long CheckSum32(uint32_t cs, u8 *Pdata, uint32_t length)
 690          {
 691   1          uint32_t i;
 692   1          for (i = 0; i < length; i++)
 693   1          {
 694   2              cs += Pdata[i];
 695   2          }
 696   1      
 697   1          return cs;
 698   1      }
 699          //#endif
 700          
 701          /*<DriverFunEnd>*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2293    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     58     119
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
